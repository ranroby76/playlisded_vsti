================================================================================
CODE DOCUMENTATION
Complete Source Code Archive
================================================================================

Generated: January 31, 2026
Total Files: 41
Generated by: Code PDF Builder

================================================================================
PROJECT STRUCTURE
================================================================================

Project Root/
├── CMakeLists.txt
└── src/
    ├── engine/
    │   ├── NativeMediaPlayer_Apple.h
    │   ├── NativeMediaPlayer_Apple.mm
    │   ├── VideoSurfaceComponent.cpp
    │   ├── VideoSurfaceComponent.h
    │   ├── VLCMediaPlayer_Desktop.cpp
    │   └── VLCMediaPlayer_Desktop.h
    ├── IPC/
    │   └── SharedMemoryManager.h
    └── UI/
        ├── DebugConsole.h
        ├── DualHandleSlider.h
        ├── EffectToggleButton.h
        ├── HeaderBar.cpp
        ├── HeaderBar.h
        ├── LongPressDetector.h
        ├── MainComponent.cpp
        ├── MainComponent.h
        ├── ManualComponent.h
        ├── MediaPage.cpp
        ├── MediaPage.h
        ├── PlaylistComponent.cpp
        ├── PlaylistComponent.h
        ├── PlaylistDataStructures.h
        ├── RegistrationComponent.h
        ├── SignalLed.h
        ├── StyledSlider.h
        ├── TrackBannerComponent.cpp
        └── TrackBannerComponent.h
    ├── AppLogger.h
    ├── AudioEngine.cpp
    ├── AudioEngine.h
    ├── EngineMain.cpp
    ├── IOSettingsManager.cpp
    ├── IOSettingsManager.h
    ├── PluginEditor.cpp
    ├── PluginEditor.h
    ├── PluginProcessor.cpp
    ├── PluginProcessor.h
    ├── PresetManager.cpp
    ├── PresetManager.h
    ├── RegistrationManager.cpp
    └── RegistrationManager.h


================================================================================
FILE DETAILS
================================================================================

1. src/AppLogger.h
   Size: 2.86 KB
   Type: text/plain

2. src/AudioEngine.cpp
   Size: 10.93 KB
   Type: text/plain

3. src/AudioEngine.h
   Size: 4.46 KB
   Type: text/plain

4. src/engine/NativeMediaPlayer_Apple.h
   Size: 2.14 KB
   Type: text/plain

5. src/engine/NativeMediaPlayer_Apple.mm
   Size: 17.49 KB
   Type: text/plain

6. src/engine/VideoSurfaceComponent.cpp
   Size: 1.59 KB
   Type: text/plain

7. src/engine/VideoSurfaceComponent.h
   Size: 1.14 KB
   Type: text/plain

8. src/engine/VLCMediaPlayer_Desktop.cpp
   Size: 9.28 KB
   Type: text/plain

9. src/engine/VLCMediaPlayer_Desktop.h
   Size: 2.50 KB
   Type: text/plain

10. src/EngineMain.cpp
   Size: 11.09 KB
   Type: text/plain

11. src/IOSettingsManager.cpp
   Size: 2.67 KB
   Type: text/plain

12. src/IOSettingsManager.h
   Size: 1.29 KB
   Type: text/plain

13. src/IPC/SharedMemoryManager.h
   Size: 9.22 KB
   Type: text/plain

14. src/PluginEditor.cpp
   Size: 0.96 KB
   Type: text/plain

15. src/PluginEditor.h
   Size: 0.76 KB
   Type: text/plain

16. src/PluginProcessor.cpp
   Size: 2.71 KB
   Type: text/plain

17. src/PluginProcessor.h
   Size: 1.50 KB
   Type: text/plain

18. src/PresetManager.cpp
   Size: 17.05 KB
   Type: text/plain

19. src/PresetManager.h
   Size: 1.44 KB
   Type: text/plain

20. src/RegistrationManager.cpp
   Size: 8.11 KB
   Type: text/plain

21. src/RegistrationManager.h
   Size: 1.12 KB
   Type: text/plain

22. src/UI/DebugConsole.h
   Size: 3.02 KB
   Type: text/plain

23. src/UI/DualHandleSlider.h
   Size: 4.93 KB
   Type: text/plain

24. src/UI/EffectToggleButton.h
   Size: 2.31 KB
   Type: text/plain

25. src/UI/HeaderBar.cpp
   Size: 4.79 KB
   Type: text/plain

26. src/UI/HeaderBar.h
   Size: 0.85 KB
   Type: text/plain

27. src/UI/LongPressDetector.h
   Size: 1.38 KB
   Type: text/plain

28. src/UI/MainComponent.cpp
   Size: 1.58 KB
   Type: text/plain

29. src/UI/MainComponent.h
   Size: 0.89 KB
   Type: text/plain

30. src/UI/ManualComponent.h
   Size: 7.45 KB
   Type: text/plain

31. src/UI/MediaPage.cpp
   Size: 6.78 KB
   Type: text/plain

32. src/UI/MediaPage.h
   Size: 1.06 KB
   Type: text/plain

33. src/UI/PlaylistComponent.cpp
   Size: 16.23 KB
   Type: text/plain

34. src/UI/PlaylistComponent.h
   Size: 2.08 KB
   Type: text/plain

35. src/UI/PlaylistDataStructures.h
   Size: 0.53 KB
   Type: text/plain

36. src/UI/RegistrationComponent.h
   Size: 9.47 KB
   Type: text/plain

37. src/UI/SignalLed.h
   Size: 1.19 KB
   Type: text/plain

38. src/UI/StyledSlider.h
   Size: 14.31 KB
   Type: text/plain

39. src/UI/TrackBannerComponent.cpp
   Size: 8.30 KB
   Type: text/plain

40. src/UI/TrackBannerComponent.h
   Size: 3.24 KB
   Type: text/plain

41. CMakeLists.txt
   Size: 10.69 KB
   Type: text/plain


================================================================================
SOURCE CODE FILES
================================================================================

--------------------------------------------------------------------------------
File: src/AppLogger.h
Size: 2.86 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    AppLogger.h
    Playlisted2

    VSTi Fix: Logs are now saved to AppData/Playlisted/Logs instead of the Desktop.

  ==============================================================================
*/

#pragma once
#include <juce_core/juce_core.h>
#include <fstream>
#include <mutex>

class AppLogger
{
public:
    enum class Level { Info, Warning, Error, Debug };
    static AppLogger& getInstance()
    {
        static AppLogger instance;
        return instance;
    }

    void log(Level level, const juce::String& message)
    {
        std::lock_guard<std::mutex> lock(mutex);
        if (!logFile.is_open()) tryOpenLogFile();
        
        if (!logFile.is_open())
        {
            DBG("[LOGFILE FAILED] " + message);
            return;
        }
            
        auto time = juce::Time::getCurrentTime().toString(true, true, true, true);
        juce::String levelStr;
        switch (level)
        {
            case Level::Info:    levelStr = "INFO"; break;
            case Level::Warning: levelStr = "WARN"; break;
            case Level::Error:   levelStr = "ERROR"; break;
            case Level::Debug:   levelStr = "DEBUG"; break;
        }
        
        juce::String logLine = "[" + time + "] [" + levelStr + "] " + message;
        logFile << logLine.toStdString() << std::endl;
        logFile.flush(); 
        DBG(logLine);
    }

    void logInfo(const juce::String& message)    { log(Level::Info, message); }
    void logWarning(const juce::String& message) { log(Level::Warning, message); }
    void logError(const juce::String& message)   { log(Level::Error, message); }
    void logDebug(const juce::String& message)   { log(Level::Debug, message); }

private:
    AppLogger() { tryOpenLogFile(); }

    ~AppLogger()
    {
        if (logFile.is_open()) logFile.close();
    }
    
    void tryOpenLogFile()
    {
        // FIX: Store logs in AppData, not Desktop
        auto appData = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
        auto logDir = appData.getChildFile("Playlisted").getChildFile("Logs");
        
        if (!logDir.exists()) logDir.createDirectory();
        
        logFilePath = logDir.getChildFile("Playlisted_VST_Log.txt");
        logFile.open(logFilePath.getFullPathName().toStdString(), std::ios::out | std::ios::app);
        
        if (logFile.is_open()) {
            logFile << "\n=== NEW SESSION ===\n" << std::endl;
        }
    }

    std::ofstream logFile;
    std::mutex mutex;
    juce::File logFilePath;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AppLogger)
};

#define LOG_INFO(msg)    AppLogger::getInstance().logInfo(msg)
#define LOG_WARNING(msg) AppLogger::getInstance().logWarning(msg)
#define LOG_ERROR(msg)   AppLogger::getInstance().logError(msg)
#define LOG_DEBUG(msg)   AppLogger::getInstance().logDebug(msg)



--------------------------------------------------------------------------------
File: src/AudioEngine.cpp
Size: 10.93 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    AudioEngine.cpp
    Playlisted2

    VSTi Compliance Fixes:
    - Fixed launchEngine() to use robust dynamic library path detection 
      (GetModuleHandleEx on Win, dladdr on Mac).
    - Fixed macOS executable name (removes .exe extension).
    - FIXED: Compilation error on Mac using dladdr with member function pointer.

  ==============================================================================
*/

#include "AudioEngine.h"
#include "AppLogger.h"

#if JUCE_WINDOWS
    #include <windows.h>
#elif JUCE_MAC
    #include <dlfcn.h> // Required for dladdr to find the VST3 bundle path
#endif

using namespace juce;

AudioEngine::AudioEngine()
{
    formatManager.registerBasicFormats();
    remotePlayer = std::make_unique<RemotePlayerFacade>(ipc);
    
    // Attempt to launch the external video engine
    launchEngine();
    // Start IPC timer
    startTimer(200); 
}

AudioEngine::~AudioEngine()
{
    stopTimer();
    stopAllPlayback();
    terminateEngine();
}

void AudioEngine::setPitchSemitones(int semitones)
{
    currentPitchSemitones = semitones;
    currentPitchFactor = std::pow(2.0f, semitones / 12.0f);
}

void AudioEngine::processPitchShift(juce::AudioBuffer<float>& buffer)
{
    if (currentPitchSemitones == 0) return;

    const int numSamples = buffer.getNumSamples();
    const int numChannels = buffer.getNumChannels();
    const int bufferLen = pitchDelayBuffer.getNumSamples();
    const int windowSize = pitchWindowSize;

    for (int ch = 0; ch < numChannels; ++ch)
    {
        auto* channelData = buffer.getWritePointer(ch);
        auto* delayData = pitchDelayBuffer.getWritePointer(ch);
        
        int localWrite = pitchWritePos;
        float localRead = pitchReadPos;

        for (int i = 0; i < numSamples; ++i)
        {
            float inputSample = channelData[i];
            delayData[localWrite] = inputSample;
            localWrite = (localWrite + 1) % bufferLen;

            float phase = pitchCrossfade + ((float)i * (1.0f - currentPitchFactor) / (float)windowSize);
            phase = phase - std::floor(phase);

            float delaySamples = phase * (float)windowSize;
            float rA = (float)localWrite - delaySamples;
            if (rA < 0) rA += bufferLen;

            int iA = (int)rA;
            float fracA = rA - iA;
            float sA = delayData[iA] * (1.0f - fracA) + delayData[(iA + 1) % bufferLen] * fracA;

            float phaseB = phase + 0.5f;
            if (phaseB >= 1.0f) phaseB -= 1.0f;
            float delaySamplesB = phaseB * (float)windowSize;

            float rB = (float)localWrite - delaySamplesB;
            if (rB < 0) rB += bufferLen;
            int iB = (int)rB;
            float fracB = rB - iB;
            float sB = delayData[iB] * (1.0f - fracB) + delayData[(iB + 1) % bufferLen] * fracB;

            float gainA = 1.0f - std::abs(2.0f * phase - 1.0f);
            float gainB = 1.0f - std::abs(2.0f * phaseB - 1.0f);

            channelData[i] = (sA * gainA + sB * gainB);
        }
        
        if (ch == numChannels - 1)
        {
            pitchWritePos = localWrite;
            float phaseIncrement = (1.0f - currentPitchFactor) / (float)windowSize;
            pitchCrossfade += phaseIncrement * numSamples;
            pitchCrossfade = pitchCrossfade - std::floor(pitchCrossfade);
        }
    }
}

void AudioEngine::timerCallback()
{
    if (!ipc.isConnected()) 
    {
        if (startupRetries < 20)
        {
            ipc.initialize();
            if (!engineProcess.isRunning())
            {
                launchEngine();
            }
            startupRetries++;
        }
    }
    else 
    {
        if (getTimerInterval() != 40) startTimer(40);
        if (startupRetries < 999) 
        {
             showVideoWindow();
             startupRetries = 999; 
        }
        remotePlayer->updateStatus();
    }
}

void AudioEngine::launchEngine()
{
    if (engineProcess.isRunning()) return;
    File engineExe;
    File pluginDir;

    // --- FIND PLUGIN BINARY LOCATION ---
    
    #if JUCE_WINDOWS
        HMODULE hModule = NULL;
        static int dummyAnchor = 0; 
        if (GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | 
                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                               (LPCSTR)&dummyAnchor, &hModule))
        {
            char path[MAX_PATH];
            if (GetModuleFileNameA(hModule, path, MAX_PATH))
            {
                pluginDir = File(path).getParentDirectory();
            }
        }
        // Windows uses .exe
        engineExe = pluginDir.getChildFile("PlaylistedEngine.exe");
    #elif JUCE_MAC
        // On Mac, we use dladdr to find the path of the VST3 bundle/dylib
        Dl_info info;
        // FIX: Use a static anchor variable instead of member function pointer
        static int dummyAnchor = 0; 
        if (dladdr((void*)&dummyAnchor, &info))
        {
            pluginDir = File(info.dli_fname).getParentDirectory();
        }
        // Mac uses no extension (Mach-O executable)
        engineExe = pluginDir.getChildFile("PlaylistedEngine");
        
        // Fallback: If inside VST3 bundle (Contents/MacOS), check sibling Resources or similar
        if (!engineExe.existsAsFile())
        {
             // Common setup: Playlisted.vst3/Contents/MacOS/Playlisted (dylib)
             // We want: Playlisted.vst3/Contents/Resources/PlaylistedEngine
             File resourcesDir = pluginDir.getParentDirectory().getChildFile("Resources");
             engineExe = resourcesDir.getChildFile("PlaylistedEngine");
        }
    #endif

    // Debug Fallback (Standalone Builds)
    if (!engineExe.existsAsFile())
    {
        File hostFile = File::getSpecialLocation(File::currentApplicationFile);
        #if JUCE_WINDOWS
            File siblingExe = hostFile.getSiblingFile("PlaylistedEngine.exe");
        #else
            File siblingExe = hostFile.getSiblingFile("PlaylistedEngine");
        #endif
        
        if (siblingExe.existsAsFile())
        {
            engineExe = siblingExe;
        }
    }

    if (engineExe.existsAsFile())
    {
        LOG_INFO("AudioEngine: Launching External Process: " + engineExe.getFullPathName());
        bool started = engineProcess.start(engineExe.getFullPathName());
        
        if (started)
        {
            LOG_INFO("AudioEngine: Process started successfully.");
            ipc.initialize();
        }
        else
        {
            LOG_ERROR("AudioEngine: Failed to start process!");
        }
    }
    else
    {
        LOG_ERROR("AudioEngine: CRITICAL - Could not find PlaylistedEngine executable at " + pluginDir.getFullPathName());
    }
}

void AudioEngine::showVideoWindow()
{
    if (!ipc.isConnected())
    {
        if (!engineProcess.isRunning()) launchEngine();
        return;
    }
    juce::DynamicObject::Ptr o = new juce::DynamicObject();
    o->setProperty("type", "show_window");
    ipc.sendCommand(JSON::toString(var(o.get())));
}

void AudioEngine::terminateEngine() 
{
    if (engineProcess.isRunning())
    {
        engineProcess.kill();
    }
}

void AudioEngine::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    ipcBuffer.setSize(2, samplesPerBlock);
    
    pitchDelayBuffer.setSize(2, 16384);
    pitchDelayBuffer.clear();
    pitchWritePos = 0;
    pitchReadPos = 0.0f;
    pitchCrossfade = 0.0f;
    
    if (!ipc.isConnected())
    {
        ipc.initialize();
    }
    
    if (ipc.isConnected())
    {
        ipc.flushAudioBuffer();
    }
    
    showVideoWindow();
}

void AudioEngine::releaseResources() {
    ipcBuffer.setSize(0, 0);
    pitchDelayBuffer.setSize(0, 0);
}

void AudioEngine::processPluginBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    if (ipcBuffer.getNumSamples() < numSamples)
        ipcBuffer.setSize(2, numSamples);

    buffer.clear();
    ipcBuffer.clear();

    handleMidi(midiMessages);

    if (!ipc.isConnected())
    {
        ipc.initialize();
    }
    
    if (ipc.isConnected())
    {
        ipc.popAudio(ipcBuffer);
        
        for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
        {
            if (ch < 2) 
            {
                buffer.copyFrom(ch, 0, ipcBuffer, ch, 0, numSamples);
            }
        }
        
        processPitchShift(buffer);
    }
}

void AudioEngine::handleMidi(juce::MidiBuffer& midiMessages)
{
    for (const auto metadata : midiMessages)
    {
        auto message = metadata.getMessage();
        if (message.isNoteOn())
        {
            int note = message.getNoteNumber();
            if (note == 15) // Play/Pause
            {
                if (remotePlayer->isPlaying()) remotePlayer->pause();
                else remotePlayer->play();
            }
            else if (note == 16) // Stop
            {
                stopAllPlayback();
            }
            else if (note == 17)
            {
                showVideoWindow();
            }
        }
    }
}

void AudioEngine::stopAllPlayback()
{
    if (remotePlayer) remotePlayer->stop();
}

void AudioEngine::updateCrossfadeState()
{
    if (remotePlayer) remotePlayer->updateStatus();
}

XmlElement* AudioEngine::getStateXml()
{
    auto* xml = new XmlElement("OnStageState");
    auto* playlistXml = new XmlElement("Playlist");
    for (const auto& item : playlist)
    {
        auto* itemXml = new XmlElement("Item");
        itemXml->setAttribute("path", item.filePath);
        itemXml->setAttribute("title", item.title);
        itemXml->setAttribute("vol", item.volume);
        itemXml->setAttribute("pitch", item.pitchSemitones);
        itemXml->setAttribute("speed", item.playbackSpeed);
        itemXml->setAttribute("delay", item.transitionDelaySec);
        itemXml->setAttribute("xfade", item.isCrossfade);
        playlistXml->addChildElement(itemXml);
    }
    xml->addChildElement(playlistXml);
    return xml;
}

void AudioEngine::setStateXml(const XmlElement* xml)
{
    if (!xml) return;
    playlist.clear();
    
    if (auto* playlistXml = xml->getChildByName("Playlist"))
    {
        for (auto* itemXml : playlistXml->getChildIterator())
        {
            PlaylistItem item;
            item.filePath = itemXml->getStringAttribute("path");
            item.title = itemXml->getStringAttribute("title");
            item.volume = (float)itemXml->getDoubleAttribute("vol", 1.0);
            item.pitchSemitones = itemXml->getIntAttribute("pitch", 0);
            item.playbackSpeed = (float)itemXml->getDoubleAttribute("speed", 1.0);
            item.transitionDelaySec = itemXml->getIntAttribute("delay", 0);
            item.isCrossfade = itemXml->getBoolAttribute("xfade", false);
            playlist.push_back(item);
        }
    }

    if (!playlist.empty())
    {
        auto& first = playlist[0];
        remotePlayer->loadFile(first.filePath);
        remotePlayer->setVolume(first.volume);
        remotePlayer->setRate(first.playbackSpeed);
        setPitchSemitones(first.pitchSemitones);
    }
}



--------------------------------------------------------------------------------
File: src/AudioEngine.h
Size: 4.46 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    AudioEngine.h
    Playlisted2

    Handles:
    - IPC with external Engine process (Video/Decoding)
    - Playlist Management
    - Pitch Shifting (Master Bus)
    
    REMOVED: Vocal Effects and Preset Manager references.

  ==============================================================================
*/

#pragma once

#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_graphics/juce_graphics.h>
#include "IPC/SharedMemoryManager.h"
#include "UI/PlaylistDataStructures.h"

class RemotePlayerFacade
{
public:
    RemotePlayerFacade(SharedMemoryManager& m) : ipc(m) {}

    bool isPlaying() const { return status.playing; }
    bool hasFinished() const { return status.finished; } 
    // Window status
    bool isWindowOpen() const { return status.winOpen; }
    
    float getPosition() const { return status.pos; }
    int64_t getLengthMs() const { return status.len; }

    juce::Image getCurrentVideoFrame() { return juce::Image(); }

    void play()  { if (ipc.isConnected()) send("play"); }
    void pause() { if (ipc.isConnected()) send("pause"); }
    void stop()  { if (ipc.isConnected()) send("stop"); }
    void setVolume(float v) { if (ipc.isConnected()) send("volume", "val", v); }
    void setRate(float r)   { if (ipc.isConnected()) send("rate", "val", r); }
    void setPosition(float p) { if (ipc.isConnected()) send("seek", "pos", p); }

    void updateStatus() { if (ipc.isConnected()) status = ipc.getEngineStatus(); }
    
    bool loadFile(const juce::String& path) {
        if (!ipc.isConnected()) return false;
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", "load");
        o->setProperty("path", path);
        o->setProperty("vol", 1.0f);
        o->setProperty("speed", 1.0f);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
        return true;
    }

private:
    SharedMemoryManager& ipc;
    SharedMemoryManager::EngineStatus status;

    void send(const juce::String& type) {
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", type);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
    }
    
    void send(const juce::String& type, const juce::String& key, float val) {
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", type);
        o->setProperty(key, val);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
    }
};

class AudioEngine : private juce::Timer
{
public:
    AudioEngine();
    ~AudioEngine();
    void prepareToPlay(double sampleRate, int samplesPerBlockExpected);
    void releaseResources();
    void processPluginBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages);
    void stopAllPlayback();
    
    RemotePlayerFacade& getMediaPlayer() { return *remotePlayer; }
    std::vector<PlaylistItem>& getPlaylist() { return playlist; }
    juce::AudioFormatManager& getFormatManager() { return formatManager; }
    
    void updateCrossfadeState();
    void showVideoWindow();

    // Pitch Control (Master)
    void setPitchSemitones(int semitones);

    // Persistent Track Index Accessors
    int getActiveTrackIndex() const { return activeTrackIndex; }
    void setActiveTrackIndex(int i) { activeTrackIndex = i; }
    
    juce::XmlElement* getStateXml();
    void setStateXml(const juce::XmlElement* xml);
    
private:
    void launchEngine();
    void terminateEngine();
    void handleMidi(juce::MidiBuffer& midiMessages);
    void timerCallback() override;

    // --- Pitch Shifter DSP ---
    void processPitchShift(juce::AudioBuffer<float>& buffer);
    juce::AudioBuffer<float> pitchDelayBuffer;
    int pitchWritePos = 0;
    float pitchReadPos = 0.0f;
    int pitchWindowSize = 4096;
    int currentPitchSemitones = 0;
    float currentPitchFactor = 1.0f;
    float pitchCrossfade = 0.0f;

    juce::AudioFormatManager formatManager;
    juce::AudioBuffer<float> ipcBuffer;
    SharedMemoryManager ipc { SharedMemoryManager::Mode::Plugin_Client };
    std::unique_ptr<RemotePlayerFacade> remotePlayer;
    juce::ChildProcess engineProcess;
    
    std::vector<PlaylistItem> playlist;
    int startupRetries = 0;

    // Store the active track index here so it survives UI close/open
    int activeTrackIndex = -1;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioEngine)
};



--------------------------------------------------------------------------------
File: src/engine/NativeMediaPlayer_Apple.h
Size: 2.14 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    NativeMediaPlayer_Apple.h
    OnStage

    Shared Native implementation for iOS AND macOS using AVFoundation.
    Uses juce::AudioTransportSource for audio-only files and AVAssetReader for video files.

  ==============================================================================
*/

#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_graphics/juce_graphics.h>

// Forward declarations for Obj-C++ wrappers
class VideoFrameExtractor; 
class AVAudioExtractor;

class NativeMediaPlayer_Apple
{
public:
    NativeMediaPlayer_Apple();
    ~NativeMediaPlayer_Apple();

    bool prepareToPlay(int samplesPerBlock, double sampleRate);
    void releaseResources();
    
    bool loadFile(const juce::String& path);
    
    void play();
    void pause();
    void stop();
    
    void setVolume(float newVolume);
    float getVolume() const;
    
    void setRate(float newRate);
    float getRate() const;
    
    bool hasFinished() const;
    bool isPlaying() const;
    
    // Position/Length
    float getPosition() const;
    void setPosition(float pos);
    int64_t getLengthMs() const;

    // Callbacks
    void getNextAudioBlock(const juce::AudioSourceChannelInfo& info);
    juce::Image getCurrentVideoFrame();

private:
    // JUCE audio path (for audio-only files)
    juce::AudioFormatManager formatManager;
    std::unique_ptr<juce::AudioFormatReaderSource> readerSource;
    juce::AudioTransportSource transportSource;
    juce::ResamplingAudioSource resampleSource {&transportSource, false, 2};

    // AVFoundation path (for video files)
    std::unique_ptr<AVAudioExtractor> avAudioExtractor;
    bool isUsingAVAudio = false;
    bool isPlayingAV = false;
    float currentVolume = 1.0f;

    double currentSampleRate = 44100.0;
    double originalSampleRate = 44100.0;
    double currentDurationSeconds = 0.0;
    float currentRate = 1.0f;

    std::unique_ptr<VideoFrameExtractor> videoExtractor;
    juce::Image currentVideoImage;
    bool isVideoLoaded = false;
};



--------------------------------------------------------------------------------
File: src/engine/NativeMediaPlayer_Apple.mm
Size: 17.49 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    NativeMediaPlayer_Apple.mm
    Playlisted2 Engine

    Implementation using AVFoundation (Shared for macOS).
    - Audio: Handled by AVAssetReader for video files, JUCE for audio-only
    - Video: Handled by AVPlayerItemVideoOutput (polled for frames)

  ==============================================================================
*/

#include "NativeMediaPlayer_Apple.h"
#include <cstdint>
#import <AVFoundation/AVFoundation.h>
#import <CoreVideo/CoreVideo.h>

// ==============================================================================
// AVFoundation Audio Reader (for video files)
// ==============================================================================
class AVAudioExtractor
{
public:
    AVAudioExtractor() {}
    ~AVAudioExtractor() { cleanUp(); }
    
    bool loadFile(const juce::String& path)
    {
        cleanUp();
        
        // FIX: Proper UTF-8 to NSString conversion for Hebrew/Unicode filenames
        NSString* nsPath = [[NSString alloc] initWithBytes:path.toRawUTF8() 
                                                    length:strlen(path.toRawUTF8()) 
                                                  encoding:NSUTF8StringEncoding];
        NSURL* url = [NSURL fileURLWithPath:nsPath];
        
        asset = [AVURLAsset assetWithURL:url];
        if (!asset) return false;
        
        // Find audio track
        NSArray* audioTracks = [asset tracksWithMediaType:AVMediaTypeAudio];
        if (audioTracks.count == 0) return false;
        
        AVAssetTrack* audioTrack = [audioTracks firstObject];
        
        NSError* error = nil;
        assetReader = [[AVAssetReader alloc] initWithAsset:asset error:&error];
        if (error || !assetReader) return false;
        
        // Audio output settings (PCM Float 32, Stereo, Native Sample Rate)
        NSDictionary* outputSettings = @{
            AVFormatIDKey: @(kAudioFormatLinearPCM),
            AVLinearPCMBitDepthKey: @(32),
            AVLinearPCMIsFloatKey: @(YES),
            AVLinearPCMIsBigEndianKey: @(NO),
            AVLinearPCMIsNonInterleaved: @(NO),
            AVNumberOfChannelsKey: @(2)
        };
        
        readerOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:audioTrack outputSettings:outputSettings];
        [assetReader addOutput:readerOutput];
        
        // Get audio format info
        NSArray* formatDescriptions = audioTrack.formatDescriptions;
        if (formatDescriptions.count > 0)
        {
            CMAudioFormatDescriptionRef desc = (__bridge CMAudioFormatDescriptionRef)formatDescriptions[0];
            const AudioStreamBasicDescription* asbd = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
            if (asbd)
            {
                sampleRate = asbd->mSampleRate;
                numChannels = asbd->mChannelsPerFrame;
            }
        }
        
        // Calculate duration
        CMTime duration = asset.duration;
        durationSeconds = CMTimeGetSeconds(duration);
        totalSamples = (int64_t)(durationSeconds * sampleRate);
        
        [assetReader startReading];
        return true;
    }
    
    void fillBuffer(float* leftChannel, float* rightChannel, int numSamples, double playbackRate)
    {
        if (!assetReader || assetReader.status != AVAssetReaderStatusReading)
        {
            // Fill with silence if reader is done or failed
            memset(leftChannel, 0, numSamples * sizeof(float));
            memset(rightChannel, 0, numSamples * sizeof(float));
            return;
        }
        
        int samplesWritten = 0;
        
        while (samplesWritten < numSamples)
        {
            // Use cached sample if available
            if (!currentSampleBuffer && cachedBufferPos >= cachedBufferSize)
            {
                currentSampleBuffer = [readerOutput copyNextSampleBuffer];
                cachedBufferPos = 0;
                cachedBufferSize = 0;
                
                if (currentSampleBuffer)
                {
                    CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(currentSampleBuffer);
                    if (blockBuffer)
                    {
                        size_t lengthAtOffset, totalLength;
                        char* dataPointer;
                        CMBlockBufferGetDataPointer(blockBuffer, 0, &lengthAtOffset, &totalLength, &dataPointer);
                        
                        cachedBuffer = (float*)dataPointer;
                        cachedBufferSize = (int)(totalLength / sizeof(float) / 2); // Stereo interleaved
                    }
                }
            }
            
            if (currentSampleBuffer && cachedBufferPos < cachedBufferSize)
            {
                int remaining = numSamples - samplesWritten;
                int available = cachedBufferSize - cachedBufferPos;
                int toCopy = juce::jmin(remaining, available);
                
                // Deinterleave stereo data
                for (int i = 0; i < toCopy; ++i)
                {
                    leftChannel[samplesWritten + i] = cachedBuffer[(cachedBufferPos + i) * 2];
                    rightChannel[samplesWritten + i] = cachedBuffer[(cachedBufferPos + i) * 2 + 1];
                }
                
                cachedBufferPos += toCopy;
                samplesWritten += toCopy;
                currentReadPosition += toCopy;
            }
            else
            {
                // Release current buffer
                if (currentSampleBuffer)
                {
                    CFRelease(currentSampleBuffer);
                    currentSampleBuffer = nullptr;
                }
                
                // No more data available
                if (assetReader.status != AVAssetReaderStatusReading)
                {
                    // Fill remaining with silence
                    int remaining = numSamples - samplesWritten;
                    memset(leftChannel + samplesWritten, 0, remaining * sizeof(float));
                    memset(rightChannel + samplesWritten, 0, remaining * sizeof(float));
                    break;
                }
            }
        }
    }
    
    void seek(double timeSeconds)
    {
        cleanUp();
        
        // Would need to recreate the asset reader at the new position
        // For now, seeking is limited - this is a known AVAssetReader limitation
        currentReadPosition = 0;
    }
    
    double getSampleRate() const { return sampleRate; }
    double getDuration() const { return durationSeconds; }
    int64_t getTotalSamples() const { return totalSamples; }
    int64_t getCurrentPosition() const { return currentReadPosition; }
    bool hasFinished() const { return assetReader && assetReader.status == AVAssetReaderStatusCompleted; }
    
    void cleanUp()
    {
        if (currentSampleBuffer)
        {
            CFRelease(currentSampleBuffer);
            currentSampleBuffer = nullptr;
        }
        assetReader = nil;
        readerOutput = nil;
        asset = nil;
        cachedBuffer = nullptr;
        cachedBufferPos = 0;
        cachedBufferSize = 0;
        currentReadPosition = 0;
    }
    
private:
    AVAsset* asset = nil;
    AVAssetReader* assetReader = nil;
    AVAssetReaderTrackOutput* readerOutput = nil;
    CMSampleBufferRef currentSampleBuffer = nullptr;
    
    float* cachedBuffer = nullptr;
    int cachedBufferPos = 0;
    int cachedBufferSize = 0;
    
    double sampleRate = 44100.0;
    int numChannels = 2;
    double durationSeconds = 0.0;
    int64_t totalSamples = 0;
    int64_t currentReadPosition = 0;
};

// ==============================================================================
// Video Frame Extractor
// ==============================================================================
class VideoFrameExtractor
{
public:
    VideoFrameExtractor() {}
    ~VideoFrameExtractor() { cleanUp(); }

    void loadVideo(const juce::String& path)
    {
        cleanUp();
        
        // FIX: Proper UTF-8 to NSString conversion for Hebrew/Unicode filenames
        NSString* nsPath = [[NSString alloc] initWithBytes:path.toRawUTF8() 
                                                    length:strlen(path.toRawUTF8()) 
                                                  encoding:NSUTF8StringEncoding];
        NSURL* url = [NSURL fileURLWithPath:nsPath];
        
        asset = [AVURLAsset assetWithURL:url];
        if (!asset) return;
        NSDictionary* settings = @{ (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
        output = [[AVPlayerItemVideoOutput alloc] initWithPixelBufferAttributes:settings];
        
        playerItem = [AVPlayerItem playerItemWithAsset:asset];
        [playerItem addOutput:output];
        player = [AVPlayer playerWithPlayerItem:playerItem];
        player.muted = YES; 
        player.actionAtItemEnd = AVPlayerActionAtItemEndPause;
    }

    juce::Image getFrameAtTime(double seconds)
    {
        if (!output) return juce::Image();
        CMTime time = CMTimeMakeWithSeconds(seconds, 600);

        if ([output hasNewPixelBufferForItemTime:time])
        {
            CMTime actualTime;
            CVPixelBufferRef buffer = [output copyPixelBufferForItemTime:time itemTimeForDisplay:&actualTime];
            
            if (buffer)
            {
                juce::Image img = convertPixelBufferToImage(buffer);
                CVPixelBufferRelease(buffer); 
                return img;
            }
        }
        return juce::Image();
    }

    void cleanUp() {
        player = nil;
        playerItem = nil;
        output = nil;
        asset = nil;
    }

private:
    AVPlayer* player = nil;
    AVPlayerItem* playerItem = nil;
    AVPlayerItemVideoOutput* output = nil;
    AVAsset* asset = nil;

    juce::Image convertPixelBufferToImage(CVPixelBufferRef buffer)
    {
        CVPixelBufferLockBaseAddress(buffer, kCVPixelBufferLock_ReadOnly);
        int width = (int)CVPixelBufferGetWidth(buffer);
        int height = (int)CVPixelBufferGetHeight(buffer);
        
        juce::uint8* srcData = (juce::uint8*)CVPixelBufferGetBaseAddress(buffer);
        size_t bytesPerRow = CVPixelBufferGetBytesPerRow(buffer);
        
        juce::Image image(juce::Image::ARGB, width, height, true);
        juce::Image::BitmapData destData(image, juce::Image::BitmapData::writeOnly);

        for (int y = 0; y < height; ++y)
        {
            const juce::uint8* srcRow = srcData + (y * bytesPerRow);
            juce::uint8* destRow = destData.getLinePointer(y);
            memcpy(destRow, srcRow, width * 4);
        }

        CVPixelBufferUnlockBaseAddress(buffer, kCVPixelBufferLock_ReadOnly);
        return image;
    }
};

// ==============================================================================
// NativeMediaPlayer_Apple Implementation
// ==============================================================================

NativeMediaPlayer_Apple::NativeMediaPlayer_Apple()
{
    formatManager.registerBasicFormats(); 
    videoExtractor = std::make_unique<VideoFrameExtractor>();
    avAudioExtractor = std::make_unique<AVAudioExtractor>();
}

NativeMediaPlayer_Apple::~NativeMediaPlayer_Apple()
{
    transportSource.setSource(nullptr);
}

bool NativeMediaPlayer_Apple::prepareToPlay(int samplesPerBlock, double sampleRate)
{
    currentSampleRate = sampleRate;
    resampleSource.prepareToPlay(samplesPerBlock, sampleRate);
    return true;
}

void NativeMediaPlayer_Apple::releaseResources()
{
    transportSource.releaseResources();
    resampleSource.releaseResources();
}

bool NativeMediaPlayer_Apple::loadFile(const juce::String& path)
{
    transportSource.stop();
    transportSource.setSource(nullptr);
    readerSource.reset();
    videoExtractor->cleanUp();
    avAudioExtractor->cleanUp();
    isVideoLoaded = false;
    isUsingAVAudio = false;
    currentVideoImage = juce::Image();

    juce::File file(path);
    
    // Check if this is a video file
    bool isVideoFile = path.endsWithIgnoreCase(".mp4") || 
                       path.endsWithIgnoreCase(".mov") || 
                       path.endsWithIgnoreCase(".m4v") || 
                       path.endsWithIgnoreCase(".avi");
    
    if (isVideoFile)
    {
        // Use AVFoundation for video files (both audio and video)
        if (avAudioExtractor->loadFile(path))
        {
            isUsingAVAudio = true;
            originalSampleRate = avAudioExtractor->getSampleRate();
            currentDurationSeconds = avAudioExtractor->getDuration();
            
            // Load video track
            videoExtractor->loadVideo(path);
            isVideoLoaded = true;
            
            return true;
        }
        return false;
    }
    else
    {
        // Use JUCE for audio-only files
        auto* reader = formatManager.createReaderFor(file);
        
        if (reader != nullptr)
        {
            originalSampleRate = reader->sampleRate;
            currentDurationSeconds = reader->lengthInSamples / reader->sampleRate;
            readerSource.reset(new juce::AudioFormatReaderSource(reader, true));
            transportSource.setSource(readerSource.get(), 32768, nullptr, reader->sampleRate);
            
            double ratio = (originalSampleRate / currentSampleRate) / (double)currentRate;
            resampleSource.setResamplingRatio(ratio);
            
            return true;
        }
        return false;
    }
}

void NativeMediaPlayer_Apple::play() 
{ 
    if (isUsingAVAudio)
        isPlayingAV = true;
    else
        transportSource.start();
}

void NativeMediaPlayer_Apple::pause() 
{ 
    if (isUsingAVAudio)
        isPlayingAV = false;
    else
        transportSource.stop(); 
}

void NativeMediaPlayer_Apple::stop()  
{ 
    if (isUsingAVAudio)
    {
        isPlayingAV = false;
        avAudioExtractor->seek(0.0);
    }
    else
    {
        transportSource.stop(); 
        transportSource.setPosition(0);
    }
    
    if (currentVideoImage.isValid())
        currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
}

void NativeMediaPlayer_Apple::setVolume(float newVolume) 
{ 
    currentVolume = newVolume;
    if (!isUsingAVAudio)
        transportSource.setGain(newVolume);
}

float NativeMediaPlayer_Apple::getVolume() const 
{ 
    return isUsingAVAudio ? currentVolume : transportSource.getGain(); 
}

void NativeMediaPlayer_Apple::setRate(float newRate)
{
    currentRate = newRate;
    if (!isUsingAVAudio && currentSampleRate > 0 && originalSampleRate > 0)
    {
        double ratio = (originalSampleRate / currentSampleRate) / (double)newRate;
        resampleSource.setResamplingRatio(ratio);
    }
}

float NativeMediaPlayer_Apple::getRate() const 
{ 
    return currentRate;
}

bool NativeMediaPlayer_Apple::hasFinished() const 
{ 
    if (isUsingAVAudio)
        return avAudioExtractor->hasFinished();
    else
        return transportSource.hasStreamFinished(); 
}

bool NativeMediaPlayer_Apple::isPlaying() const 
{ 
    if (isUsingAVAudio)
        return isPlayingAV;
    else
        return transportSource.isPlaying();
}

float NativeMediaPlayer_Apple::getPosition() const
{
    if (isUsingAVAudio)
    {
        if (currentDurationSeconds > 0)
        {
            double currentPos = avAudioExtractor->getCurrentPosition() / avAudioExtractor->getSampleRate();
            return (float)(currentPos / currentDurationSeconds);
        }
        return 0.0f;
    }
    else
    {
        if (transportSource.getLengthInSeconds() > 0)
            return (float)(transportSource.getCurrentPosition() / transportSource.getLengthInSeconds());
        return 0.0f;
    }
}

void NativeMediaPlayer_Apple::setPosition(float pos)
{
    if (isUsingAVAudio)
    {
        double timeSeconds = pos * currentDurationSeconds;
        avAudioExtractor->seek(timeSeconds);
    }
    else
    {
        if (transportSource.getLengthInSeconds() > 0)
            transportSource.setPosition(pos * transportSource.getLengthInSeconds());
    }
}

int64_t NativeMediaPlayer_Apple::getLengthMs() const
{
    if (isUsingAVAudio)
        return (int64_t)(currentDurationSeconds * 1000.0);
    else
        return (int64_t)(transportSource.getLengthInSeconds() * 1000.0);
}

void NativeMediaPlayer_Apple::getNextAudioBlock(const juce::AudioSourceChannelInfo& info)
{
    if (isUsingAVAudio)
    {
        if (!isPlayingAV)
        {
            info.clearActiveBufferRegion();
            return;
        }
        
        // Fill from AVAudioExtractor
        auto* leftChannel = info.buffer->getWritePointer(0, info.startSample);
        auto* rightChannel = info.buffer->getNumChannels() > 1 ? 
                            info.buffer->getWritePointer(1, info.startSample) : nullptr;
        
        avAudioExtractor->fillBuffer(leftChannel, 
                                     rightChannel ? rightChannel : leftChannel, 
                                     info.numSamples, 
                                     currentRate);
        
        // Apply volume
        if (currentVolume != 1.0f)
        {
            info.buffer->applyGain(info.startSample, info.numSamples, currentVolume);
        }
    }
    else
    {
        resampleSource.getNextAudioBlock(info);
    }
}

juce::Image NativeMediaPlayer_Apple::getCurrentVideoFrame()
{
    if (!isVideoLoaded) return juce::Image();

    double currentSeconds;
    if (isUsingAVAudio)
        currentSeconds = avAudioExtractor->getCurrentPosition() / avAudioExtractor->getSampleRate();
    else
        currentSeconds = transportSource.getCurrentPosition();
    
    juce::Image frame = videoExtractor->getFrameAtTime(currentSeconds);
    if (frame.isValid())
        currentVideoImage = frame;
        
    return currentVideoImage;
}



--------------------------------------------------------------------------------
File: src/engine/VideoSurfaceComponent.cpp
Size: 1.59 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    VideoSurfaceComponent.cpp
    Playlisted2

    Implementation of the placeholder video component for the VST editor.
    Since the actual video plays in a separate process/window, this component
    serves as a status indicator or black backdrop in the UI.

  ==============================================================================
*/

#include "VideoSurfaceComponent.h"
#include "../AudioEngine.h"

VideoSurfaceComponent::VideoSurfaceComponent(AudioEngine& engine)
    : audioEngine(engine)
{
    // Start a timer to update UI if necessary (e.g. blinking rec light or status)
    startTimer(40); // 25fps update rate
}

VideoSurfaceComponent::~VideoSurfaceComponent()
{
    stopTimer();
}

void VideoSurfaceComponent::paint(juce::Graphics& g)
{
    // Draw a black background to represent the video area
    g.fillAll(juce::Colours::black);

    // Optional: Draw text indicating video is running externally
    g.setColour(juce::Colours::white.withAlpha(0.5f));
    g.setFont(14.0f);
    g.drawText("Video Output (External Window)", getLocalBounds(), juce::Justification::centred, true);
    
    // Draw a border
    g.setColour(juce::Colour(0xFF404040));
    g.drawRect(getLocalBounds(), 1);
}

void VideoSurfaceComponent::resized()
{
    // Layout logic if you add child components later
}

void VideoSurfaceComponent::timerCallback()
{
    // Repaint to keep UI responsive or animate if needed
    // For a static placeholder, this could be removed, but we keep it to match the header's inheritance of Timer.
    repaint();
}



--------------------------------------------------------------------------------
File: src/engine/VideoSurfaceComponent.h
Size: 1.14 KB
--------------------------------------------------------------------------------

// **Fix:** Removed references to `VLCMediaPlayer` and simplified it, since the video is now handled by the external window. **File Location: D:\\Workspace\\onstage\_with\_chatgpt\_10\\src\\engine\\VideoSurfaceComponent.h**

/*
  ==============================================================================

    VideoSurfaceComponent.h
    Playlisted2

    For the VST3: This is just a placeholder black screen because the 
    actual video runs in the external "PiP" Engine window.

  ==============================================================================
*/

#ifndef ONSTAGE_ENGINE_VIDEO_SURFACE_COMPONENT_H
#define ONSTAGE_ENGINE_VIDEO_SURFACE_COMPONENT_H

#include <juce_gui_basics/juce_gui_basics.h>

// Forward Declaration
class AudioEngine;

class VideoSurfaceComponent : public juce::Component, private juce::Timer
{
public:
    VideoSurfaceComponent(AudioEngine& engine);
    ~VideoSurfaceComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    
    AudioEngine& audioEngine;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VideoSurfaceComponent)
};
#endif



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer_Desktop.cpp
Size: 9.28 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    VLCMediaPlayer_Desktop.cpp
    Playlisted2 Engine

  ==============================================================================
*/

#include "VLCMediaPlayer_Desktop.h"
#include <cstring>
#include <juce_core/juce_core.h>

#if JUCE_WINDOWS
#include <windows.h>
#include <stdlib.h>
#endif

static bool loadVlcDlls(const juce::File& appDir)
{
    #if JUCE_WINDOWS
    juce::File vlcCore = appDir.getChildFile("libvlccore.dll");
    juce::File vlcLib  = appDir.getChildFile("libvlc.dll");

    if (!vlcCore.exists()) return false;
    if (!vlcLib.exists()) return false;

    if (!LoadLibraryA(vlcCore.getFullPathName().toRawUTF8())) return false;
    if (!LoadLibraryA(vlcLib.getFullPathName().toRawUTF8())) return false;
    return true;
    #else
    return true;
    #endif
}

VLCMediaPlayer_Desktop::VLCMediaPlayer_Desktop()
{
}

VLCMediaPlayer_Desktop::~VLCMediaPlayer_Desktop()
{
    stop();
    if (m_mediaPlayer) libvlc_media_player_release(m_mediaPlayer);
    if (m_instance) libvlc_release(m_instance);
}

void VLCMediaPlayer_Desktop::ensureInitialized()
{
    if (isInitialized) return;

    juce::File appDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    
    bool dllsLoaded = loadVlcDlls(appDir);
    if (dllsLoaded)
    {
        juce::File vlcPlugins = appDir.getChildFile("plugins");
        if (vlcPlugins.isDirectory())
        {
            #if JUCE_WINDOWS
                juce::String pathEnv = "VLC_PLUGIN_PATH=" + vlcPlugins.getFullPathName();
                _putenv(pathEnv.toRawUTF8());
            #endif
        }

        const char* args[] = { 
            "--aout=amem", 
            "--no-video-title-show",
            "--no-osd",
            "--no-xlib",
            "--quiet",
            
            // --- SYNC FIXES ---
            "--avcodec-hw=any",       
            "--vout=direct3d9",       
            "--no-drop-late-frames",  
            "--no-skip-frames", 
            
            // FIX: Re-enable strict clock sync to keep video tied to audio clock
            "--clock-jitter=0",
            "--clock-synchro=0",

            // Reduce caching for tighter response
            "--file-caching=150",     
            "--network-caching=150" 
        };
        m_instance = libvlc_new(sizeof(args) / sizeof(args[0]), args);
        if (m_instance)
        {
            m_mediaPlayer = libvlc_media_player_new(m_instance);
            if (m_mediaPlayer)
            {
                libvlc_audio_set_callbacks(m_mediaPlayer, audioPlay, audioPause, audioResume, audioFlush, audioDrain, this);
                libvlc_audio_set_format(m_mediaPlayer, "S16N", static_cast<int>(currentSampleRate), 2);
            }
        }
    }
    
    isInitialized = true;
}

bool VLCMediaPlayer_Desktop::prepareToPlay(int samplesPerBlock, double sampleRate)
{
    if (sampleRate > 1000.0) currentSampleRate = sampleRate;
    else currentSampleRate = 44100.0;

    ensureInitialized();
    maxBlockSize = samplesPerBlock;
    
    // Resize with new smaller constant
    ringBuffer.setSize(2, InternalBufferSize); 
    fifo.setTotalSize(ringBuffer.getNumSamples());
    fifo.reset();

    if (m_mediaPlayer)
    {
        libvlc_audio_set_format(m_mediaPlayer, "S16N", static_cast<int>(currentSampleRate), 2);
    }

    isPrepared = true;
    return true;
}

void VLCMediaPlayer_Desktop::releaseResources()
{
    stop();
    fifo.reset();
    ringBuffer.clear();
    isPrepared = false;
}

void VLCMediaPlayer_Desktop::setWindowHandle(void* handle)
{
    ensureInitialized();
    if (m_mediaPlayer && handle != nullptr)
    {
        #if JUCE_WINDOWS
            libvlc_media_player_set_hwnd(m_mediaPlayer, handle);
        #elif JUCE_MAC
            libvlc_media_player_set_nsobject(m_mediaPlayer, handle);
        #elif JUCE_LINUX
            libvlc_media_player_set_xwindow(m_mediaPlayer, (uint32_t)(uintptr_t)handle);
        #endif
    }
}

void VLCMediaPlayer_Desktop::setVideoEnabled(bool enabled)
{
    if (m_mediaPlayer)
    {
        libvlc_video_set_track(m_mediaPlayer, enabled ? 0 : -1);
    }
}

void VLCMediaPlayer_Desktop::flushAudioBuffers()
{
    juce::ScopedLock sl(audioLock);
    fifo.reset();
    ringBuffer.clear();
}

bool VLCMediaPlayer_Desktop::loadFile(const juce::String& path)
{
    ensureInitialized();
    if (!m_instance || !m_mediaPlayer) return false;
    
    libvlc_media_player_set_rate(m_mediaPlayer, 1.0f);
    int rate = (currentSampleRate > 0) ? static_cast<int>(currentSampleRate) : 44100;
    libvlc_audio_set_format(m_mediaPlayer, "S16N", rate, 2);

    // FIX: Use file:/// URI with proper URL encoding for Unicode support
    juce::URL fileURL = juce::URL(juce::File(path));
    juce::String urlString = fileURL.toString(true); // URL-encode the path
    
    libvlc_media_t* media = libvlc_media_new_location(m_instance, urlString.toUTF8());
    if (media == nullptr) return false;

    libvlc_media_player_set_media(m_mediaPlayer, media);
    libvlc_media_release(media);
    
    flushAudioBuffers();
    return true;
}

void VLCMediaPlayer_Desktop::play()
{
    if (m_mediaPlayer) libvlc_media_player_play(m_mediaPlayer);
}

void VLCMediaPlayer_Desktop::pause()
{
    flushAudioBuffers();
    if (m_mediaPlayer) libvlc_media_player_pause(m_mediaPlayer);
}

void VLCMediaPlayer_Desktop::stop()
{
    if (m_mediaPlayer) libvlc_media_player_stop(m_mediaPlayer);
    flushAudioBuffers();
}

void VLCMediaPlayer_Desktop::setVolume(float newVolume) { volume = newVolume; }
float VLCMediaPlayer_Desktop::getVolume() const { return volume; }

void VLCMediaPlayer_Desktop::setRate(float newRate) 
{ 
    if (m_mediaPlayer) 
    {
        // Must flush to prevent hearing old-speed audio
        flushAudioBuffers();
        libvlc_media_player_set_rate(m_mediaPlayer, newRate);
    }
}

float VLCMediaPlayer_Desktop::getRate() const { return m_mediaPlayer ? libvlc_media_player_get_rate(m_mediaPlayer) : 1.0f; }

bool VLCMediaPlayer_Desktop::hasFinished() const { 
    if (!m_mediaPlayer) return false; 
    return libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Ended;
}

bool VLCMediaPlayer_Desktop::isPlaying() const { 
    if (!m_mediaPlayer) return false; 
    return libvlc_media_player_is_playing(m_mediaPlayer) != 0;
}

float VLCMediaPlayer_Desktop::getPosition() const { 
    if (!m_mediaPlayer) return 0.0f; 
    return libvlc_media_player_get_position(m_mediaPlayer);
}

void VLCMediaPlayer_Desktop::setPosition(float pos) 
{ 
    if (m_mediaPlayer) 
    {
        flushAudioBuffers();
        libvlc_media_player_set_position(m_mediaPlayer, pos);
    }
}

int64_t VLCMediaPlayer_Desktop::getLengthMs() const { 
    if (!m_mediaPlayer) return 0; 
    return libvlc_media_player_get_length(m_mediaPlayer);
}

int VLCMediaPlayer_Desktop::getNumAudioSamplesAvailable() const
{
    return fifo.getNumReady();
}

void VLCMediaPlayer_Desktop::audioPlay(void* data, const void* samples, unsigned count, int64_t pts) {
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self) self->addAudioSamples(samples, count, pts);
}
void VLCMediaPlayer_Desktop::audioPause(void*, int64_t) {}
void VLCMediaPlayer_Desktop::audioResume(void*, int64_t) {}
void VLCMediaPlayer_Desktop::audioFlush(void* data, int64_t) {
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self) self->flushAudioBuffers();
}
void VLCMediaPlayer_Desktop::audioDrain(void*) {}

void VLCMediaPlayer_Desktop::addAudioSamples(const void* samples, unsigned count, int64_t pts) {
    juce::ScopedLock sl(audioLock);
    const int space = fifo.getFreeSpace();
    int toWrite = juce::jmin(static_cast<int>(count), space);
    if (toWrite > 0) {
        int start1, size1, start2, size2;
        fifo.prepareToWrite(toWrite, start1, size1, start2, size2);
        const int16_t* src = static_cast<const int16_t*>(samples);
        const float scale = 1.0f / 32768.0f;
        if (size1 > 0) { 
            for (int i = 0; i < size1; ++i) { 
                ringBuffer.setSample(0, start1 + i, src[i * 2] * scale);
                ringBuffer.setSample(1, start1 + i, src[i * 2 + 1] * scale);
            } 
        }
        if (size2 > 0) { 
            for (int i = 0; i < size2; ++i) { 
                ringBuffer.setSample(0, start2 + i, src[(size1 + i) * 2] * scale);
                ringBuffer.setSample(1, start2 + i, src[(size1 + i) * 2 + 1] * scale);
            } 
        }
        fifo.finishedWrite(size1 + size2);
    }
}

void VLCMediaPlayer_Desktop::getNextAudioBlock(const juce::AudioSourceChannelInfo& info) {
    if (!isPrepared) { info.clearActiveBufferRegion(); return; }
    if (libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Paused) { info.clearActiveBufferRegion(); return; }
    
    juce::ScopedLock sl(audioLock);
    int toRead = juce::jmin(info.numSamples, fifo.getNumReady());
    if (toRead > 0) {
        int start1, size1, start2, size2;
        fifo.prepareToRead(toRead, start1, size1, start2, size2);
        if (size1 > 0) for (int ch = 0; ch < 2; ++ch) info.buffer->addFrom(ch, info.startSample, ringBuffer, ch, start1, size1, volume);
        if (size2 > 0) for (int ch = 0; ch < 2; ++ch) info.buffer->addFrom(ch, info.startSample + size1, ringBuffer, ch, start2, size2, volume);
        fifo.finishedRead(size1 + size2);
    }
    if (toRead < info.numSamples) info.buffer->clear(info.startSample + toRead, info.numSamples - toRead);
}



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer_Desktop.h
Size: 2.50 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    VLCMediaPlayer_Desktop.h
    Playlisted2

  ==============================================================================
*/

#ifndef ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_DESKTOP_H
#define ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_DESKTOP_H

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_graphics/juce_graphics.h> 

extern "C" {
    #include <vlc/libvlc.h>
    #include <vlc/libvlc_media.h>
    #include <vlc/libvlc_renderer_discoverer.h> 
    #include <vlc/libvlc_media_player.h>
}

class VLCMediaPlayer_Desktop
{
public:
    VLCMediaPlayer_Desktop();
    ~VLCMediaPlayer_Desktop();

    bool prepareToPlay(int samplesPerBlock, double sampleRate);
    void releaseResources();
    bool loadFile(const juce::String& path);
    void play();
    void pause();
    void stop();
    void setVolume(float newVolume);
    float getVolume() const;
    void setRate(float newRate);
    float getRate() const;
    bool hasFinished() const;

    void getNextAudioBlock(const juce::AudioSourceChannelInfo& info);
    int getNumAudioSamplesAvailable() const;

    void setWindowHandle(void* handle);
    
    void setVideoEnabled(bool enabled);
    bool isPlaying() const;
    float getPosition() const;
    void setPosition(float pos);
    int64_t getLengthMs() const;
    
    void flushAudioBuffers();

private:
    void ensureInitialized();
    bool isInitialized = false;

    // Audio Callbacks
    static void audioPlay(void* data, const void* samples, unsigned count, int64_t pts);
    static void audioPause(void* data, int64_t pts);
    static void audioResume(void* data, int64_t pts);
    static void audioFlush(void* data, int64_t pts);
    static void audioDrain(void* data);

    void addAudioSamples(const void* samples, unsigned count, int64_t pts);

    libvlc_instance_t* m_instance = nullptr;
    libvlc_media_player_t* m_mediaPlayer = nullptr;
    juce::CriticalSection audioLock;
    
    // FIX: Reduced buffer size from 131072 to 16384 to fix A/V Sync drift
    // 16384 samples @ 44.1k is approx 370ms, which is much tighter than the previous 3s buffer
    static const int InternalBufferSize = 16384;
    juce::AudioBuffer<float> ringBuffer {2, InternalBufferSize}; 
    juce::AbstractFifo fifo {InternalBufferSize};

    double currentSampleRate = 44100.0;
    int maxBlockSize = 512;
    float volume = 1.0f;
    bool isPrepared = false;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VLCMediaPlayer_Desktop)
};
#endif



--------------------------------------------------------------------------------
File: src/EngineMain.cpp
Size: 11.09 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    EngineMain.cpp
    Playlisted2 Engine (Standalone Process)
    
    SINGLE DECK ARCHITECTURE - CROSS PLATFORM (Win/Mac)
    - Windows: Uses VLCMediaPlayer_Desktop (Direct HWND Rendering)
    - macOS: Uses NativeMediaPlayer_Apple (AVFoundation Image Extraction)

  ==============================================================================
*/

#include <juce_core/juce_core.h>
#include <juce_events/juce_events.h>
#include <juce_graphics/juce_graphics.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include "IPC/SharedMemoryManager.h"
#include <fstream>

// --- PLATFORM INCLUDES ---
#if JUCE_WINDOWS
    #include "engine/VLCMediaPlayer_Desktop.h"
    using PlatformPlayer = VLCMediaPlayer_Desktop;
#elif JUCE_MAC
    #include "engine/NativeMediaPlayer_Apple.h"
    using PlatformPlayer = NativeMediaPlayer_Apple;
#endif

void logToDesktop(const juce::String& text)
{
    auto desktop = juce::File::getSpecialLocation(juce::File::userDesktopDirectory);
    auto logFile = desktop.getChildFile("OnStage_EngineLog.txt");
    
    std::ofstream stream(logFile.getFullPathName().toStdString(), std::ios::app);
    if (stream.is_open())
    {
        auto time = juce::Time::getCurrentTime().toString(true, true, true, true);
        stream << "[" << time.toStdString() << "] " << text.toStdString() << std::endl;
    }
}

// ==============================================================================
// VIDEO COMPONENT (Handles Drawing)
// ==============================================================================
class VideoComponent : public juce::Component, private juce::Timer
{
public:
    VideoComponent() { setOpaque(true); }

    #if JUCE_MAC
    void setPlayer(PlatformPlayer* p) 
    { 
        player = p; 
        // Mac needs to poll for frames
        startTimerHz(30); 
    }

    void timerCallback() override 
    {
        if (player && player->isPlaying()) 
        {
            // Fetch frame from AVFoundation
            juce::Image newFrame = player->getCurrentVideoFrame();
            if (newFrame.isValid())
            {
                currentFrame = newFrame;
                repaint();
            }
        }
        else if (player && !player->isPlaying() && currentFrame.isValid())
        {
            // Keep drawing the last frame if paused, or clear if stopped?
            // For now, repaint to ensure updates
            repaint();
        }
    }

    void paint(juce::Graphics& g) override 
    { 
        g.fillAll(juce::Colours::black);
        
        if (currentFrame.isValid())
        {
            // Draw video frame scaling to fit
            g.drawImage(currentFrame, getLocalBounds().toFloat(), juce::RectanglePlacement::centred);
        }
    }
    
    private:
        PlatformPlayer* player = nullptr;
        juce::Image currentFrame;

    #else
    // Windows (VLC handles painting directly to the window handle)
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colours::black); }
    
    // FIX: Must implement timerCallback on Windows too, even if empty, 
    // because we inherit from juce::Timer.
    void timerCallback() override {}
    #endif
};

// ==============================================================================
// VIDEO WINDOW
// ==============================================================================
class VideoWindow : public juce::DocumentWindow
{
public:
    VideoWindow() 
        : DocumentWindow("Playlisted2 Video Output", juce::Colours::black, DocumentWindow::allButtons)
    {
        setUsingNativeTitleBar(true);
        videoComp = new VideoComponent();
        setContentOwned(videoComp, true);
        setResizable(true, true);
        setAlwaysOnTop(true);
        centreWithSize(640, 360);
        setVisible(true);
    }
    
    void* getNativeHandle()
    {
        if (auto* peer = getPeer())
            return peer->getNativeHandle();
        return nullptr;
    }
    
    // Helper to pass player to component (Mac only needs this)
    void bindPlayer(PlatformPlayer* player)
    {
        #if JUCE_MAC
        if (videoComp) videoComp->setPlayer(player);
        #endif
    }
    
    void closeButtonPressed() override { 
        setVisible(false);
    }

private:
    VideoComponent* videoComp = nullptr;
};

// ==============================================================================
// SINGLE DECK CLASS (WRAPPER)
// ==============================================================================
class SingleDeckPlayer
{
public:
    SingleDeckPlayer()
    {
        player.prepareToPlay(512, 44100.0);
    }

    void setVideoWindow(VideoWindow* win)
    {
        window = win;
        
        #if JUCE_WINDOWS
            // Windows: Pass HWND to VLC
            if (window && window->getNativeHandle()) 
                player.setWindowHandle(window->getNativeHandle());
        #elif JUCE_MAC
            // Mac: Pass Player instance to Window for polling
            if (window)
                window->bindPlayer(&player);
        #endif
    }

    void load(const juce::String& path, float vol, float rate)
    {
        player.stop();
        
        #if JUCE_WINDOWS
        // Ensure handle is set before loading to prevent popup
        if (window && window->getNativeHandle()) 
            player.setWindowHandle(window->getNativeHandle());
        #endif

        player.loadFile(path);
        player.setVolume(vol);
        player.setRate(rate);
    }

    void play() { player.play(); }
    void pause() { player.pause(); }
    void stop() { player.stop(); }

    void getNextAudioBlock(const juce::AudioSourceChannelInfo& info)
    {
        player.getNextAudioBlock(info);
    }

    bool isPlaying() { return player.isPlaying(); }
    bool hasFinished() { return player.hasFinished(); }
    float getPosition() { return player.getPosition(); }
    int64_t getLengthMs() { return player.getLengthMs(); }
    
    void setVolume(float v) { player.setVolume(v); }
    void setRate(float r) { player.setRate(r); }
    void setPosition(float p) { player.setPosition(p); }
    
    int getNumAudioSamplesAvailable() 
    { 
        #if JUCE_WINDOWS
            return player.getNumAudioSamplesAvailable(); 
        #else
            // AVFoundation implementation might not use the same FIFO structure explicitly exposed
            // But NativeMediaPlayer_Apple usually handles this internally via ResamplingAudioSource.
            // If the native class doesn't expose this method, we can mock it or add it.
            // Checking NativeMediaPlayer_Apple.h... it DOES NOT expose getNumAudioSamplesAvailable.
            // However, it pulls synchronously via getNextAudioBlock.
            // So we can always return block size to keep the pump running.
            return 4096; 
        #endif
    }

private:
    PlatformPlayer player;
    VideoWindow* window = nullptr;
};

// ==============================================================================
// APPLICATION MAIN
// ==============================================================================
class PlaylistedEngineApplication : public juce::JUCEApplication, public juce::Thread
{
public:
    PlaylistedEngineApplication() : Thread("AudioPumpThread") {}

    const juce::String getApplicationName() override       { return "PlaylistedEngine"; }
    const juce::String getApplicationVersion() override    { return "2.0.0"; }
    bool moreThanOneInstanceAllowed() override             { return false; }
    
    void anotherInstanceStarted(const juce::String&) override
    {
        if (videoWin)
        {
            videoWin->setVisible(true);
            if (videoWin->isMinimised()) videoWin->setMinimised(false);
            videoWin->toFront(true);
        }
    }

    void initialise(const juce::String&) override
    {
        logToDesktop("Engine Process Started (Single Deck Mode)");
        if (!ipc.initialize()) { 
            quit(); 
            return;
        }

        videoWin = std::make_unique<VideoWindow>();
        videoWin->toFront(true);
        
        player.setVideoWindow(videoWin.get());

        startThread(juce::Thread::Priority::highest);
    }

    void shutdown() override
    {
        signalThreadShouldExit();
        stopThread(2000);
        videoWin = nullptr;
    }

    void run() override
    {
        const int blockSize = 512;
        juce::AudioBuffer<float> tempBuffer(2, blockSize);
        juce::AudioSourceChannelInfo info(&tempBuffer, 0, blockSize);
        int counter = 0;

        while (!threadShouldExit())
        {
            juce::String cmdJson = ipc.getNextCommand();
            if (cmdJson.isNotEmpty()) {
                handleCommand(cmdJson);
            }

            // Audio Pumping
            // On Windows (VLC), we wait for FIFO.
            // On Mac (Native), getNextAudioBlock blocks/pulls from reader.
            if (player.getNumAudioSamplesAvailable() >= blockSize)
            {
                tempBuffer.clear();
                player.getNextAudioBlock(info);
                ipc.pushAudio(tempBuffer.getArrayOfReadPointers(), 2, blockSize);
            }

            if (counter++ % 4 == 0)
            {
                // Push status to shared memory, including Window Visibility
                bool isWinOpen = (videoWin && videoWin->isVisible());
                ipc.setEngineStatus(
                    player.isPlaying(), 
                    player.hasFinished(),
                    isWinOpen,
                    player.getPosition(), 
                    player.getLengthMs()
                );
            }
            wait(2);
        }
    }

private:
    void handleCommand(const juce::String& json)
    {
        auto var = juce::JSON::parse(json);
        if (!var.isObject()) return;
        juce::String type = var["type"];
        
        if (type == "load") {
            juce::String path = var["path"];
            float vol = var.hasProperty("vol") ? (float)var["vol"] : 1.0f;
            float rate = var.hasProperty("speed") ? (float)var["speed"] : 1.0f;
            
            player.load(path, vol, rate);
            juce::MessageManager::callAsync([this]() {
                if (videoWin && !videoWin->isVisible()) {
                    videoWin->setVisible(true);
                    videoWin->toFront(true);
                }
            });
        }
        else if (type == "play")  { player.play(); }
        else if (type == "pause") { player.pause(); }
        else if (type == "stop")  { player.stop(); }
        else if (type == "seek")  { player.setPosition((float)var["pos"]); }
        else if (type == "volume"){ player.setVolume((float)var["val"]); }
        else if (type == "rate")  { player.setRate((float)var["val"]); }
        else if (type == "show_window") {
            juce::MessageManager::callAsync([this]() {
                if (videoWin) {
                    if (videoWin->isMinimised()) videoWin->setMinimised(false);
                    videoWin->setVisible(true);
                    videoWin->toFront(true);
                }
            });
        }
    }

    SharedMemoryManager ipc { SharedMemoryManager::Mode::Engine_Server };
    SingleDeckPlayer player;
    std::unique_ptr<VideoWindow> videoWin;
};
START_JUCE_APPLICATION(PlaylistedEngineApplication)



--------------------------------------------------------------------------------
File: src/IOSettingsManager.cpp
Size: 2.67 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    IOSettingsManager.cpp
    Playlisted2

  ==============================================================================
*/

#include "IOSettingsManager.h"
#include "AppLogger.h"
#include <juce_core/juce_core.h>

IOSettingsManager::IOSettingsManager()
{
    lastMediaFolder = juce::File::getSpecialLocation(juce::File::userMusicDirectory).getFullPathName();
    lastPlaylistFolder = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory).getFullPathName();
    lastMidiDevice = "";
}

void IOSettingsManager::saveMediaFolder(const juce::String& path) { lastMediaFolder = path; saveToFile(); }
void IOSettingsManager::savePlaylistFolder(const juce::String& path) { lastPlaylistFolder = path; saveToFile(); }
void IOSettingsManager::saveMidiDevice(const juce::String& deviceName) { lastMidiDevice = deviceName; saveToFile(); }

bool IOSettingsManager::loadSettings()
{
    auto file = getSettingsFile();
    if (!file.existsAsFile()) {
        LOG_INFO("IOSettingsManager: Settings file not found at " + file.getFullPathName());
        return false;
    }
    
    LOG_INFO("IOSettingsManager: Loading settings from " + file.getFullPathName());
    try {
        auto json = juce::JSON::parse(file);
        if (auto* obj = json.getDynamicObject())
        {
            if (obj->hasProperty("mediaFolder")) lastMediaFolder = obj->getProperty("mediaFolder").toString();
            if (obj->hasProperty("playlistFolder")) lastPlaylistFolder = obj->getProperty("playlistFolder").toString();
            if (obj->hasProperty("midiDevice")) lastMidiDevice = obj->getProperty("midiDevice").toString();

            LOG_INFO("IOSettingsManager: Load Complete.");
            return true;
        }
    }
    catch (...) {
        LOG_ERROR("IOSettingsManager: Failed to parse JSON");
    }
    return false;
}

bool IOSettingsManager::hasExistingSettings() const { return getSettingsFile().existsAsFile(); }

juce::File IOSettingsManager::getSettingsFile() const {
    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
    auto pluginDir = appDataDir.getChildFile("Playlisted");
    if (!pluginDir.exists()) pluginDir.createDirectory();
    return pluginDir.getChildFile("plugin_settings.json");
}

bool IOSettingsManager::saveToFile()
{
    auto file = getSettingsFile();
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    
    obj->setProperty("mediaFolder", lastMediaFolder);
    obj->setProperty("playlistFolder", lastPlaylistFolder);
    obj->setProperty("midiDevice", lastMidiDevice);
    
    file.replaceWithText(juce::JSON::toString(juce::var(obj.get())));
    return true;
}



--------------------------------------------------------------------------------
File: src/IOSettingsManager.h
Size: 1.29 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    IOSettingsManager.h
    Playlisted2

    VSTi Cleanup: Removed Audio Driver selection (handled by DAW)
    and Vocal Inputs (removed feature).
    Now purely manages Folders and MIDI preferences.

  ==============================================================================
*/

#pragma once
#include <juce_core/juce_core.h>
#include <juce_data_structures/juce_data_structures.h>

class IOSettingsManager
{
public:
    IOSettingsManager();
    ~IOSettingsManager() = default;

    // Folders
    void saveMediaFolder(const juce::String& path);
    juce::String getMediaFolder() const { return lastMediaFolder; }

    void savePlaylistFolder(const juce::String& path);
    juce::String getPlaylistFolder() const { return lastPlaylistFolder; }

    // MIDI Settings
    void saveMidiDevice(const juce::String& deviceName);
    juce::String getLastMidiDevice() const { return lastMidiDevice; }

    bool loadSettings();
    bool hasExistingSettings() const;

private:
    juce::File getSettingsFile() const;
    bool saveToFile();

    juce::String lastMediaFolder = ""; 
    juce::String lastPlaylistFolder = "";
    juce::String lastMidiDevice = "";
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(IOSettingsManager)
};



--------------------------------------------------------------------------------
File: src/IPC/SharedMemoryManager.h
Size: 9.22 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    SharedMemoryManager.h
    Playlisted2

    Handles Inter-Process Communication (IPC) via Memory Mapped Files.
    FIXED: Added flushAudioBuffer to prevent "ghost audio" bursts on startup.
  ==============================================================================
*/

#pragma once
#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <algorithm> // Added for std::fill

namespace IPCConfig
{
    // BUMPED VERSION TO v3 to support new Window State flag
    static const char* SharedMemoryName = "Playlisted2_SharedMem_v3.dat";
    // Audio Settings
    static const int SampleRate = 44100;
    static const int BlockSize  = 512;
    static const int NumChannels = 2;
    
    // Size of the Ring Buffer (Power of 2 is best for wrapping logic)
    static const int AudioBufferSize = 65536;
    static const int CommandQueueSize = 16;
    static const int CommandBufferSize = 4096;
}

// Command Queue Structure
struct CommandSlot
{
    std::atomic<bool> ready { false };
    char data[IPCConfig::CommandBufferSize];
};

struct SharedMemoryLayout
{
    // --- STATUS ---
    std::atomic<bool> isEngineRunning { false };
    std::atomic<bool> isPlaying { false };
    std::atomic<bool> hasFinished { false };
    // NEW: Window Visibility Flag
    std::atomic<bool> isWindowOpen { true };
    
    std::atomic<float> currentPosition { 0.0f };
    std::atomic<int64_t> currentLengthMs { 0 };
    std::atomic<double> currentCallbackTime { 0.0 };

    // --- AUDIO ---
    std::atomic<int> audioWritePos { 0 };
    std::atomic<int> audioReadPos { 0 };
    float audioBuffer[IPCConfig::AudioBufferSize * IPCConfig::NumChannels];

    // --- COMMANDS (QUEUE) ---
    std::atomic<int> commandWriteIndex { 0 };
    std::atomic<int> commandReadIndex { 0 };
    CommandSlot commands[IPCConfig::CommandQueueSize];
};

class SharedMemoryManager
{
public:
    enum class Mode { Plugin_Client, Engine_Server };

    SharedMemoryManager(Mode mode) : currentMode(mode) {}

    ~SharedMemoryManager()
    {
        mappedFile.reset();
    }

    bool initialize()
    {
        auto tempDir = juce::File::getSpecialLocation(juce::File::tempDirectory);
        auto sharedFile = tempDir.getChildFile(IPCConfig::SharedMemoryName);

        if (currentMode == Mode::Engine_Server)
        {
            // SERVER: Create file
            if (sharedFile.exists())
            {
                if (!sharedFile.deleteFile()) { }
            }

            // Ensure file exists with correct size
            if (sharedFile.create())
            {
                // Only fill if empty
                if (sharedFile.getSize() != sizeof(SharedMemoryLayout))
                {
                    sharedFile.deleteFile();
                    sharedFile.create();
                    juce::MemoryBlock zeros(sizeof(SharedMemoryLayout), true);
                    bool success = sharedFile.appendData(zeros.getData(), zeros.getSize());
                    if (!success) return false;
                }
            }
            else return false;
        }
        else
        {
            // CLIENT: Wait for file to exist
            if (!sharedFile.existsAsFile()) return false;
            // Wait for size to settle
            if (sharedFile.getSize() < sizeof(SharedMemoryLayout)) return false;
        }

        try
        {
            mappedFile = std::make_unique<juce::MemoryMappedFile>(
                sharedFile, 
                juce::MemoryMappedFile::AccessMode::readWrite
            );
            layout = static_cast<SharedMemoryLayout*>(mappedFile->getData());
        }
        catch (...)
        {
            return false;
        }

        // Initialize (Server only sets flag)
        if (currentMode == Mode::Engine_Server && layout)
        {
            layout->isEngineRunning.store(true);
        }

        return (layout != nullptr);
    }

    bool isConnected() const 
    { 
        return layout != nullptr && layout->isEngineRunning.load();
    }

    // ==============================================================================
    // AUDIO METHODS
    // ==============================================================================
    
    // FIX: New method to wipe the buffer clean on startup
    void flushAudioBuffer()
    {
        if (!layout) return;
        
        // Reset pointers
        layout->audioReadPos.store(0);
        layout->audioWritePos.store(0);
        
        // Zero out the entire buffer memory to prevent old audio bursts
        std::fill(std::begin(layout->audioBuffer), std::end(layout->audioBuffer), 0.0f);
    }

    void pushAudio(const float* const* channelData, int numChannels, int numSamples)
    {
        if (!layout) return;
        int writePos = layout->audioWritePos.load();
        int totalSize = IPCConfig::AudioBufferSize * IPCConfig::NumChannels;

        for (int i = 0; i < numSamples; ++i)
        {
            for (int ch = 0; ch < IPCConfig::NumChannels; ++ch)
            {
                float sample = (ch < numChannels) ? channelData[ch][i] : 0.0f;
                layout->audioBuffer[writePos] = sample;
                writePos = (writePos + 1) % totalSize;
            }
        }
        
        layout->audioWritePos.store(writePos);
    }

    void popAudio(juce::AudioBuffer<float>& buffer)
    {
        if (!layout) { buffer.clear(); return; }

        int numSamples = buffer.getNumSamples();
        int readPos = layout->audioReadPos.load();
        int writePos = layout->audioWritePos.load();

        int totalSize = IPCConfig::AudioBufferSize * IPCConfig::NumChannels;
        int availableFloats = (writePos - readPos + totalSize) % totalSize;
        int availableFrames = availableFloats / IPCConfig::NumChannels;

        // Underrun protection
        if (availableFrames < numSamples)
        {
            buffer.clear();
            return; 
        }

        auto* l = buffer.getWritePointer(0);
        auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;

        for (int i = 0; i < numSamples; ++i)
        {
            float left = layout->audioBuffer[readPos];
            readPos = (readPos + 1) % totalSize;
            
            float right = layout->audioBuffer[readPos];
            readPos = (readPos + 1) % totalSize;

            l[i] = left;
            if (r) r[i] = right;
        }

        layout->audioReadPos.store(readPos);
    }

    // ==============================================================================
    // COMMAND METHODS - FIX FOR HEBREW/UNICODE
    // ==============================================================================

    void sendCommand(const juce::String& jsonCommand)
    {
        if (!layout) return;
        int writeIdx = layout->commandWriteIndex.load();
        int nextWriteIdx = (writeIdx + 1) % IPCConfig::CommandQueueSize;

        // Check if queue is full
        if (nextWriteIdx == layout->commandReadIndex.load()) return;

        auto& slot = layout->commands[writeIdx];
        
        // FIX: Use strlen to get actual UTF-8 byte count, not character count
        const char* utf8Data = jsonCommand.toRawUTF8();
        size_t utf8ByteLength = strlen(utf8Data);
        size_t bytesToCopy = juce::jmin(utf8ByteLength, (size_t)(IPCConfig::CommandBufferSize - 1));
        
        memset(slot.data, 0, IPCConfig::CommandBufferSize);
        memcpy(slot.data, utf8Data, bytesToCopy);
        
        slot.ready.store(true);
        layout->commandWriteIndex.store(nextWriteIdx);
    }

    juce::String getNextCommand()
    {
        if (!layout) return {};
        int readIdx = layout->commandReadIndex.load();
        int writeIdx = layout->commandWriteIndex.load();
        
        if (readIdx == writeIdx) return {};
        auto& slot = layout->commands[readIdx];
        if (!slot.ready.load()) return {};
        
        // FIX: Explicitly construct UTF-8 string
        juce::String cmd = juce::String::fromUTF8(slot.data);
        
        slot.ready.store(false);
        layout->commandReadIndex.store((readIdx + 1) % IPCConfig::CommandQueueSize);
        
        return cmd;
    }

    // ==============================================================================
    // STATUS SYNC
    // ==============================================================================
    
    // Updated setEngineStatus to include Window Visibility
    void setEngineStatus(bool playing, bool finished, bool winOpen, float pos, int64_t len)
    {
        if (!layout) return;
        layout->isPlaying.store(playing);
        layout->hasFinished.store(finished);
        layout->isWindowOpen.store(winOpen);
        layout->currentPosition.store(pos);
        layout->currentLengthMs.store(len);
    }

    struct EngineStatus { bool playing; bool finished; bool winOpen; float pos; int64_t len; };
    EngineStatus getEngineStatus()
    {
        if (!layout) return { false, false, false, 0.0f, 0 };
        return { 
            layout->isPlaying.load(), 
            layout->hasFinished.load(), 
            layout->isWindowOpen.load(),
            layout->currentPosition.load(), 
            layout->currentLengthMs.load() 
        };
    }

private:
    Mode currentMode;
    std::unique_ptr<juce::MemoryMappedFile> mappedFile;
    SharedMemoryLayout* layout = nullptr;
};



--------------------------------------------------------------------------------
File: src/PluginEditor.cpp
Size: 0.96 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    PluginEditor.cpp
    Playlisted2

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

PlaylistedProcessorEditor::PlaylistedProcessorEditor (PlaylistedAudioProcessor& p)
    : AudioProcessorEditor (&p), audioProcessor (p)
{
    // Pass references from the Processor to the MainComponent
    mainComponent = std::make_unique<MainComponent>(p.getAudioEngine(), p.getSettings());
    addAndMakeVisible(mainComponent.get());

    setResizable(true, true);
    setResizeLimits(800, 500, 1920, 1080);
    setSize(1000, 700);
}

PlaylistedProcessorEditor::~PlaylistedProcessorEditor()
{
}

void PlaylistedProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll(juce::Colour(0xFF202020));
}

void PlaylistedProcessorEditor::resized()
{
    if (mainComponent)
        mainComponent->setBounds(getLocalBounds());
}



--------------------------------------------------------------------------------
File: src/PluginEditor.h
Size: 0.76 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    PluginEditor.h
    Playlisted2

  ==============================================================================
*/

#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include "PluginProcessor.h"
#include "UI/MainComponent.h"

class PlaylistedProcessorEditor  : public juce::AudioProcessorEditor
{
public:
    PlaylistedProcessorEditor (PlaylistedAudioProcessor&);
    ~PlaylistedProcessorEditor() override;

    void paint (juce::Graphics&) override;
    void resized() override;

private:
    PlaylistedAudioProcessor& audioProcessor;
    std::unique_ptr<MainComponent> mainComponent;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PlaylistedProcessorEditor)
};



--------------------------------------------------------------------------------
File: src/PluginProcessor.cpp
Size: 2.71 KB
--------------------------------------------------------------------------------

#include "PluginProcessor.h"
#include "PluginEditor.h"

PlaylistedAudioProcessor::PlaylistedAudioProcessor()
#ifndef JucePlugin_PreferredChannelConfigurations
     : AudioProcessor (BusesProperties().withOutput ("Output", juce::AudioChannelSet::stereo(), true))
#endif
{
}

PlaylistedAudioProcessor::~PlaylistedAudioProcessor() {}

const juce::String PlaylistedAudioProcessor::getName() const { return "Playlisted"; }
bool PlaylistedAudioProcessor::acceptsMidi() const { return true; }
bool PlaylistedAudioProcessor::producesMidi() const { return false; }
bool PlaylistedAudioProcessor::isMidiEffect() const { return false; }
double PlaylistedAudioProcessor::getTailLengthSeconds() const { return 0.0; }
int PlaylistedAudioProcessor::getNumPrograms() { return 1; }
int PlaylistedAudioProcessor::getCurrentProgram() { return 0; }
void PlaylistedAudioProcessor::setCurrentProgram (int index) {}
const juce::String PlaylistedAudioProcessor::getProgramName (int index) { return {}; }
void PlaylistedAudioProcessor::changeProgramName (int index, const juce::String& newName) {}

void PlaylistedAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    audioEngine.prepareToPlay(sampleRate, samplesPerBlock);
}

void PlaylistedAudioProcessor::releaseResources()
{
    audioEngine.releaseResources();
}

bool PlaylistedAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;
    return true;
}

void PlaylistedAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    audioEngine.processPluginBlock(buffer, midiMessages);
}

bool PlaylistedAudioProcessor::hasEditor() const { return true; }

juce::AudioProcessorEditor* PlaylistedAudioProcessor::createEditor() { 
    return new PlaylistedProcessorEditor (*this);
}

void PlaylistedAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    std::unique_ptr<juce::XmlElement> xml(audioEngine.getStateXml());
    copyXmlToBinary(*xml, destData);
}

void PlaylistedAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
    if (xmlState.get() != nullptr)
    {
        if (xmlState->hasTagName("OnStageState") || xmlState->hasTagName("PlaylistedState"))
        {
            audioEngine.setStateXml(xmlState.get());
            if (auto* editor = dynamic_cast<PlaylistedProcessorEditor*>(getActiveEditor()))
            {
                editor->repaint();
            }
        }
    }
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PlaylistedAudioProcessor();
}



--------------------------------------------------------------------------------
File: src/PluginProcessor.h
Size: 1.50 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include "AudioEngine.h"
#include "IOSettingsManager.h"

class PlaylistedAudioProcessor  : public juce::AudioProcessor
{
public:
    PlaylistedAudioProcessor();
    ~PlaylistedAudioProcessor() override;
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    const juce::String getName() const override;
    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    AudioEngine& getAudioEngine() { return audioEngine; }
    IOSettingsManager& getSettings() { return ioSettings; }

private:
    AudioEngine audioEngine;
    IOSettingsManager ioSettings;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PlaylistedAudioProcessor)
};



--------------------------------------------------------------------------------
File: src/PresetManager.cpp
Size: 17.05 KB
--------------------------------------------------------------------------------

#include "PresetManager.h"
#include <juce_core/juce_core.h>

PresetManager::PresetManager(AudioEngine& engine)
    : audioEngine(engine), currentPresetName("Default")
{
    loadDefaultPreset();
}

void PresetManager::loadDefaultPreset()
{
    // ==============================================================================
    // Channel 1 settings (Based on UPDATED Preset "a12")
    // ==============================================================================
    audioEngine.setMicPreampGain(0, -1.9f);
    audioEngine.setMicMute(0, false);       // Updated: Mute is false
    audioEngine.setFxBypass(0, false);

    // --- EQ 1 ---
    auto& eq1 = audioEngine.getEQProcessor(0);
    eq1.setLowFrequency(638.05f);
    eq1.setMidFrequency(1000.0f);
    eq1.setHighFrequency(2713.07f);
    
    eq1.setLowGain(-4.92f);
    eq1.setMidGain(0.0f);
    eq1.setHighGain(0.0f);
    
    eq1.setLowQ(2.38f);
    eq1.setMidQ(6.49f);
    eq1.setHighQ(5.69f);
    
    eq1.setBypassed(false);
    
    // --- Compressor 1 ---
    auto& comp1 = audioEngine.getCompressorProcessor(0);
    CompressorProcessor::Params params1;
    params1.thresholdDb = -18.0f;
    params1.ratio = 2.33f;
    params1.attackMs = 0.1f;
    params1.releaseMs = 54.55f;
    params1.makeupDb = 3.96f;
    comp1.setParams(params1);
    comp1.setBypassed(false);

    // --- Exciter 1 ---
    auto& exc1 = audioEngine.getExciterProcessor(0);
    ExciterProcessor::Params exParams1;
    exParams1.frequency = 1990.0f;
    exParams1.amount = 6.96f;  // Updated
    exParams1.mix = 0.58f;
    exc1.setParams(exParams1);
    exc1.setBypassed(false);
    
    // ==============================================================================
    // Channel 2 settings
    // ==============================================================================
    audioEngine.setMicPreampGain(1, 0.0f);
    audioEngine.setMicMute(1, false);
    audioEngine.setFxBypass(1, false);

    // --- EQ 2 ---
    auto& eq2 = audioEngine.getEQProcessor(1);
    eq2.setLowFrequency(648.96f); // Updated
    eq2.setMidFrequency(1000.0f);
    eq2.setHighFrequency(2731.96f); // Updated
    
    eq2.setLowGain(0.0f);
    eq2.setMidGain(0.0f);
    eq2.setHighGain(0.0f);
    
    eq2.setLowQ(0.707f);
    eq2.setMidQ(0.707f);
    eq2.setHighQ(0.707f);
    
    eq2.setBypassed(false);
    
    // --- Compressor 2 ---
    auto& comp2 = audioEngine.getCompressorProcessor(1);
    CompressorProcessor::Params params2;
    params2.thresholdDb = -18.0f;
    params2.ratio = 3.0f;
    params2.attackMs = 8.0f;
    params2.releaseMs = 120.0f;
    params2.makeupDb = 0.0f;
    comp2.setParams(params2);
    comp2.setBypassed(false);

    // --- Exciter 2 ---
    auto& exc2 = audioEngine.getExciterProcessor(1);
    ExciterProcessor::Params exParams2;
    exParams2.frequency = 2350.0f; // Updated
    exParams2.amount = 1.92f;      // Updated
    exParams2.mix = 0.11f;         // Updated
    exc2.setParams(exParams2);
    exc2.setBypassed(false);

    // ==============================================================================
    // Global Effects
    // ==============================================================================

    // --- Harmonizer ---
    auto& harmonizer = audioEngine.getHarmonizerProcessor();
    HarmonizerProcessor::Params harmParams;
    harmParams.enabled = true;
    harmParams.wetDb = -3.12f;
    harmParams.glideMs = 50.0f; 
    
    harmParams.voices[0].enabled = true;
    harmParams.voices[0].fixedSemitones = 2.88f;
    harmParams.voices[0].gainDb = -6.0f;
    
    harmParams.voices[1].enabled = true;
    harmParams.voices[1].fixedSemitones = 7.20f;
    harmParams.voices[1].gainDb = -6.0f;
    
    harmonizer.setParams(harmParams);
    harmonizer.setBypassed(true); // Updated: Harmonizer bypass is TRUE in new JSON

    // --- Reverb ---
    auto& reverb = audioEngine.getReverbProcessor();
    ReverbProcessor::Params reverbParams;
    reverbParams.wetGain = 1.9f; // Updated
    reverbParams.lowCutHz = 470.8f;
    reverbParams.highCutHz = 9360.0f;
    reverbParams.irFilePath = ""; 
    reverb.setParams(reverbParams);
    reverb.setBypassed(false);

    // --- Delay ---
    auto& delay = audioEngine.getDelayProcessor();
    DelayProcessor::Params delayParams;
    delayParams.delayMs = 350.0f;
    delayParams.ratio = 0.3f;   
    delayParams.stage = 0.25f; 
    delayParams.mix = 1.0f;
    delayParams.stereoWidth = 1.0f;
    delayParams.lowCutHz = 200.0f;
    delayParams.highCutHz = 8000.0f;
    delay.setParams(delayParams);
    delay.setBypassed(true);

    // --- Dynamic EQ (Sidechain) ---
    auto& dynEQ = audioEngine.getDynamicEQProcessor();
    DynamicEQProcessor::Params dynEQParams;
    dynEQParams.duckBandHz = 1838.0f;
    dynEQParams.q = 7.33f;
    dynEQParams.shape = 0.5f;
    dynEQParams.threshold = -14.4f;
    dynEQParams.ratio = 2.52f;
    dynEQParams.attack = 6.09f;
    dynEQParams.release = 128.8f;
    dynEQ.setParams(dynEQParams);
    dynEQ.setBypassed(false);
    
    currentPresetName = "a12";
}

juce::String PresetManager::getCurrentPresetName() const
{
    return currentPresetName;
}

// ==============================================================================
// SAVE
// ==============================================================================
bool PresetManager::savePreset(const juce::File& file)
{
    juce::DynamicObject::Ptr root = new juce::DynamicObject();
    root->setProperty("presetName", file.getFileNameWithoutExtension());
    root->setProperty("version", "1.0");

    // --- Mics ---
    juce::Array<juce::var> mics;
    for (int i = 0; i < 2; ++i)
    {
        juce::DynamicObject::Ptr micObj = new juce::DynamicObject();
        micObj->setProperty("preampGain", audioEngine.getMicPreampGain(i));
        micObj->setProperty("mute", audioEngine.isMicMuted(i));
        micObj->setProperty("fxBypass", audioEngine.isFxBypassed(i));

        auto& eq = audioEngine.getEQProcessor(i);
        juce::DynamicObject::Ptr eqObj = new juce::DynamicObject();
        eqObj->setProperty("lowFreq", eq.getLowFrequency());
        eqObj->setProperty("midFreq", eq.getMidFrequency());
        eqObj->setProperty("highFreq", eq.getHighFrequency());
        eqObj->setProperty("lowGain", eq.getLowGain());
        eqObj->setProperty("midGain", eq.getMidGain());
        eqObj->setProperty("highGain", eq.getHighGain());
        eqObj->setProperty("lowQ", eq.getLowQ());
        eqObj->setProperty("midQ", eq.getMidQ());
        eqObj->setProperty("highQ", eq.getHighQ());
        micObj->setProperty("eq", eqObj.get());
        micObj->setProperty("eqBypass", eq.isBypassed());

        auto& comp = audioEngine.getCompressorProcessor(i);
        micObj->setProperty("compressor", compParamsToVar(comp.getParams()));
        micObj->setProperty("compBypass", comp.isBypassed());

        auto& exc = audioEngine.getExciterProcessor(i);
        micObj->setProperty("exciter", exciterParamsToVar(exc.getParams()));
        micObj->setProperty("excBypass", exc.isBypassed());

        mics.add(micObj.get());
    }
    root->setProperty("mics", mics);

    // --- Globals ---
    auto& harm = audioEngine.getHarmonizerProcessor();
    root->setProperty("harmonizer", harmonizerParamsToVar(harm.getParams()));
    root->setProperty("harmonizerBypass", harm.isBypassed());

    auto& verb = audioEngine.getReverbProcessor();
    root->setProperty("reverb", reverbParamsToVar(verb.getParams()));
    root->setProperty("reverbBypass", verb.isBypassed());

    auto& delay = audioEngine.getDelayProcessor();
    root->setProperty("delay", delayParamsToVar(delay.getParams()));
    root->setProperty("delayBypass", delay.isBypassed());

    auto& dynEq = audioEngine.getDynamicEQProcessor();
    root->setProperty("dynamicEQ", dynEqParamsToVar(dynEq.getParams()));
    root->setProperty("dynEqBypass", dynEq.isBypassed());

    juce::String jsonString = juce::JSON::toString(juce::var(root), false);
    if (file.replaceWithText(jsonString))
    {
        currentPresetName = file.getFileNameWithoutExtension();
        return true;
    }
    return false;
}

// ==============================================================================
// LOAD
// ==============================================================================
bool PresetManager::loadPreset(const juce::File& file)
{
    if (!file.existsAsFile()) return false;
    auto jsonVar = juce::JSON::parse(file);
    if (!jsonVar.isObject()) return false;

    auto* root = jsonVar.getDynamicObject();

    if (auto* mics = root->getProperty("mics").getArray())
    {
        for (int i = 0; i < juce::jmin(2, mics->size()); ++i)
        {
            if (auto* micObj = mics->getReference(i).getDynamicObject())
            {
                audioEngine.setMicPreampGain(i, (float)micObj->getProperty("preampGain"));
                audioEngine.setMicMute(i, (bool)micObj->getProperty("mute"));
                audioEngine.setFxBypass(i, (bool)micObj->getProperty("fxBypass"));

                if (auto* eqObj = micObj->getProperty("eq").getDynamicObject())
                {
                    auto& eq = audioEngine.getEQProcessor(i);
                    eq.setLowFrequency((float)eqObj->getProperty("lowFreq"));
                    eq.setMidFrequency((float)eqObj->getProperty("midFreq"));
                    eq.setHighFrequency((float)eqObj->getProperty("highFreq"));
                    eq.setLowGain((float)eqObj->getProperty("lowGain"));
                    eq.setMidGain((float)eqObj->getProperty("midGain"));
                    eq.setHighGain((float)eqObj->getProperty("highGain"));
                    eq.setLowQ((float)eqObj->getProperty("lowQ"));
                    eq.setMidQ((float)eqObj->getProperty("midQ"));
                    eq.setHighQ((float)eqObj->getProperty("highQ"));
                    eq.setBypassed((bool)micObj->getProperty("eqBypass"));
                }

                auto& comp = audioEngine.getCompressorProcessor(i);
                comp.setParams(varToCompParams(micObj->getProperty("compressor")));
                comp.setBypassed((bool)micObj->getProperty("compBypass"));

                auto& exc = audioEngine.getExciterProcessor(i);
                if (micObj->hasProperty("exciter"))
                {
                    exc.setParams(varToExciterParams(micObj->getProperty("exciter")));
                    exc.setBypassed((bool)micObj->getProperty("excBypass"));
                }
            }
        }
    }

    auto& harm = audioEngine.getHarmonizerProcessor();
    harm.setParams(varToHarmonizerParams(root->getProperty("harmonizer")));
    harm.setBypassed((bool)root->getProperty("harmonizerBypass"));

    auto& verb = audioEngine.getReverbProcessor();
    verb.setParams(varToReverbParams(root->getProperty("reverb")));
    verb.setBypassed((bool)root->getProperty("reverbBypass"));

    auto& delay = audioEngine.getDelayProcessor();
    delay.setParams(varToDelayParams(root->getProperty("delay")));
    delay.setBypassed((bool)root->getProperty("delayBypass"));

    auto& dynEq = audioEngine.getDynamicEQProcessor();
    dynEq.setParams(varToDynEqParams(root->getProperty("dynamicEQ")));
    dynEq.setBypassed((bool)root->getProperty("dynEqBypass"));

    currentPresetName = file.getFileNameWithoutExtension();
    return true;
}

// ==============================================================================
// HELPERS
// ==============================================================================

juce::var PresetManager::eqParamsToVar(const EQProcessor::Params& params) { return {}; }

juce::var PresetManager::compParamsToVar(const CompressorProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("thresh", p.thresholdDb);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("attack", p.attackMs);
    obj->setProperty("release", p.releaseMs);
    obj->setProperty("makeup", p.makeupDb);
    return obj.get();
}

CompressorProcessor::Params PresetManager::varToCompParams(const juce::var& v)
{
    CompressorProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.thresholdDb = (float)obj->getProperty("thresh");
        p.ratio = (float)obj->getProperty("ratio");
        p.attackMs = (float)obj->getProperty("attack");
        p.releaseMs = (float)obj->getProperty("release");
        p.makeupDb = (float)obj->getProperty("makeup");
    }
    return p;
}

juce::var PresetManager::exciterParamsToVar(const ExciterProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("freq", p.frequency);
    obj->setProperty("drive", p.amount);
    obj->setProperty("mix", p.mix);
    return obj.get();
}

ExciterProcessor::Params PresetManager::varToExciterParams(const juce::var& v)
{
    ExciterProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.frequency = (float)obj->getProperty("freq");
        p.amount = (float)obj->getProperty("drive");
        p.mix = (float)obj->getProperty("mix");
    }
    return p;
}

juce::var PresetManager::reverbParamsToVar(const ReverbProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("wet", p.wetGain);
    obj->setProperty("loCut", p.lowCutHz);
    obj->setProperty("hiCut", p.highCutHz);
    obj->setProperty("irPath", p.irFilePath);
    return obj.get();
}

ReverbProcessor::Params PresetManager::varToReverbParams(const juce::var& v)
{
    ReverbProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.wetGain = (float)obj->getProperty("wet");
        p.lowCutHz = (float)obj->getProperty("loCut");
        p.highCutHz = (float)obj->getProperty("hiCut");
        p.irFilePath = obj->getProperty("irPath").toString();
    }
    return p;
}

juce::var PresetManager::delayParamsToVar(const DelayProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("time", p.delayMs);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("stage", p.stage);
    obj->setProperty("mix", p.mix);
    obj->setProperty("width", p.stereoWidth);
    obj->setProperty("loCut", p.lowCutHz);
    obj->setProperty("hiCut", p.highCutHz);
    return obj.get();
}

DelayProcessor::Params PresetManager::varToDelayParams(const juce::var& v)
{
    DelayProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.delayMs = (float)obj->getProperty("time");
        p.ratio = (float)obj->getProperty("ratio");
        p.stage = (float)obj->getProperty("stage");
        p.mix = (float)obj->getProperty("mix");
        p.stereoWidth = (float)obj->getProperty("width");
        p.lowCutHz = (float)obj->getProperty("loCut");
        p.highCutHz = (float)obj->getProperty("hiCut");
    }
    return p;
}

juce::var PresetManager::harmonizerParamsToVar(const HarmonizerProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("enabled", p.enabled);
    obj->setProperty("wet", p.wetDb);
    
    juce::DynamicObject::Ptr v1 = new juce::DynamicObject();
    v1->setProperty("on", p.voices[0].enabled);
    v1->setProperty("pitch", p.voices[0].fixedSemitones);
    v1->setProperty("gain", p.voices[0].gainDb);
    obj->setProperty("v1", v1.get());

    juce::DynamicObject::Ptr v2 = new juce::DynamicObject();
    v2->setProperty("on", p.voices[1].enabled);
    v2->setProperty("pitch", p.voices[1].fixedSemitones);
    v2->setProperty("gain", p.voices[1].gainDb);
    obj->setProperty("v2", v2.get());

    return obj.get();
}

HarmonizerProcessor::Params PresetManager::varToHarmonizerParams(const juce::var& v)
{
    HarmonizerProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.enabled = (bool)obj->getProperty("enabled");
        p.wetDb = (float)obj->getProperty("wet");
        
        if (auto* v1 = obj->getProperty("v1").getDynamicObject())
        {
            p.voices[0].enabled = (bool)v1->getProperty("on");
            p.voices[0].fixedSemitones = (float)v1->getProperty("pitch");
            p.voices[0].gainDb = (float)v1->getProperty("gain");
        }
        if (auto* v2 = obj->getProperty("v2").getDynamicObject())
        {
            p.voices[1].enabled = (bool)v2->getProperty("on");
            p.voices[1].fixedSemitones = (float)v2->getProperty("pitch");
            p.voices[1].gainDb = (float)v2->getProperty("gain");
        }
    }
    return p;
}

juce::var PresetManager::dynEqParamsToVar(const DynamicEQProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("freq", p.duckBandHz);
    obj->setProperty("q", p.q);
    obj->setProperty("shape", p.shape);
    obj->setProperty("thresh", p.threshold);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("att", p.attack);
    obj->setProperty("rel", p.release);
    return obj.get();
}

DynamicEQProcessor::Params PresetManager::varToDynEqParams(const juce::var& v)
{
    DynamicEQProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.duckBandHz = (float)obj->getProperty("freq");
        p.q = (float)obj->getProperty("q");
        p.shape = (float)obj->getProperty("shape");
        p.threshold = (float)obj->getProperty("thresh");
        p.ratio = (float)obj->getProperty("ratio");
        p.attack = (float)obj->getProperty("att");
        p.release = (float)obj->getProperty("rel");
    }
    return p;
}



--------------------------------------------------------------------------------
File: src/PresetManager.h
Size: 1.44 KB
--------------------------------------------------------------------------------

// Ensuring it includes `AudioEngine.h` correctly.

#pragma once

#include <juce_core/juce_core.h>
#include "AudioEngine.h"

class PresetManager
{
public:
    PresetManager(AudioEngine& engine);
    ~PresetManager() = default;

    bool savePreset(const juce::File& file);
    bool loadPreset(const juce::File& file);
    void loadDefaultPreset();
    juce::String getCurrentPresetName() const;

private:
    AudioEngine& audioEngine;
    juce::String currentPresetName;

    juce::var eqParamsToVar(const EQProcessor::Params& params);
    
    juce::var compParamsToVar(const CompressorProcessor::Params& params);
    CompressorProcessor::Params varToCompParams(const juce::var& v);

    juce::var exciterParamsToVar(const ExciterProcessor::Params& params);
    ExciterProcessor::Params varToExciterParams(const juce::var& v);

    juce::var reverbParamsToVar(const ReverbProcessor::Params& params);
    ReverbProcessor::Params varToReverbParams(const juce::var& v);
    
    juce::var delayParamsToVar(const DelayProcessor::Params& params);
    DelayProcessor::Params varToDelayParams(const juce::var& v);

    juce::var harmonizerParamsToVar(const HarmonizerProcessor::Params& params);
    HarmonizerProcessor::Params varToHarmonizerParams(const juce::var& v);
    
    juce::var dynEqParamsToVar(const DynamicEQProcessor::Params& params);
    DynamicEQProcessor::Params varToDynEqParams(const juce::var& v);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PresetManager)
};



--------------------------------------------------------------------------------
File: src/RegistrationManager.cpp
Size: 8.11 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    RegistrationManager.cpp
    Playlisted2

    VSTi Fix: Updated data storage folder from "OnStage" to "Playlisted".

  ==============================================================================
*/

#include "RegistrationManager.h"
#include "BinaryData.h" 
#include "AppLogger.h"
#include <string>
#include <vector>
#include <cmath>
#include <fstream> 

#if JUCE_WINDOWS
#include <windows.h>
#endif

void RegistrationManager::checkRegistration()
{
    // FIX: Updated folder name to Playlisted
    juce::File licenseFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                             .getChildFile("Playlisted").getChildFile("license.key");
    if (licenseFile.existsAsFile())
    {
        juce::String savedSerial = licenseFile.loadFileAsString().trim();
        if (savedSerial.isNotEmpty())
        {
            if (tryRegister(savedSerial))
            {
                isRegistered = true;
                return;
            }
        }
    }
    isRegistered = false;
}

bool RegistrationManager::tryRegister(const juce::String& serialInput)
{
    try {
        juce::String cleanInput = serialInput.trim();
        if (cleanInput.isEmpty() || !cleanInput.containsOnly("0123456789")) return false;

        long long inputNum = cleanInput.getLargeIntValue();
        long long expected = calculateExpectedSerial();
        LOG_INFO("Input Serial: " + cleanInput);

        if (expected != 0 && inputNum == expected)
        {
            // FIX: Updated folder name to Playlisted
            juce::File appData = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory).getChildFile("Playlisted");
            if (!appData.exists()) appData.createDirectory();
            
            juce::File licenseFile = appData.getChildFile("license.key");
            licenseFile.replaceWithText(cleanInput);
            
            isRegistered = true;
            return true;
        }
        
        return false;
    }
    catch (...) { 
        LOG_ERROR("Exception in tryRegister");
        return false;
    }
}

juce::String RegistrationManager::getMachineIDString()
{
    return juce::String(getMachineIDNumber());
}

char RegistrationManager::noteToChar(int note)
{
    if (note >= 0 && note <= 9) return '0' + note;
    switch(note) {
        case 10: return 'a';
        case 11: return '+';
        case 12: return '-';
        case 13: return '*';
        case 14: return '(';
        case 15: return ')';
    }
    return 0; 
}

juce::String RegistrationManager::decodeMidiToString(const void* data, size_t size)
{
    if (size == 0 || data == nullptr) return "";
    try {
        juce::MemoryInputStream inputStream(data, size, false);
        juce::MidiFile midiFile;
        if (midiFile.readFrom(inputStream))
        {
            midiFile.convertTimestampTicksToSeconds();
            juce::String extractedString = "";
            for (int t = 0; t < midiFile.getNumTracks(); ++t)
            {
                const auto* seq = midiFile.getTrack(t);
                for (int i = 0; i < seq->getNumEvents(); ++i)
                {
                    auto& event = seq->getEventPointer(i)->message;
                    if (event.isNoteOn() && event.getChannel() == 16)
                    {
                        char c = noteToChar(event.getNoteNumber());
                        if (c != 0) extractedString += c;
                    }
                }
            }
            return extractedString;
        }
    }
    catch (...) { 
        LOG_ERROR("MIDI Decode Crashed");
    }
    
    return "";
}

long long RegistrationManager::calculateExpectedSerial()
{
    try {
        int machineId = getMachineIDNumber();
        juce::String formula = decodeMidiToString(BinaryData::license_mid, BinaryData::license_midSize);
        
        if (formula.isEmpty()) {
            LOG_ERROR("CRITICAL: Failed to decode formula from MIDI asset.");
            return 0;
        }

        juce::String finalExpr = formula.replace("a", juce::String(machineId));
        long long rawResult = evaluateFormula(finalExpr);
        return rawResult / 10;
    }
    catch (...) { 
        LOG_ERROR("Calculation Exception");
        return 0; 
    }
}

long long RegistrationManager::evaluateFormula(const juce::String& formula)
{
    try {
        std::string expr = formula.removeCharacters(" ").toStdString();
        if (expr.empty()) return 0;

        struct Parser {
            const char* str;
            char peek() { return *str; }
            char next() { return *str ? *str++ : 0; }

            long long parseExpression() {
                long long lhs = parseTerm();
                while (peek() == '+' || peek() == '-') {
                    char op = next();
                    long long rhs = parseTerm();
                    if (op == '+') lhs += rhs; else lhs -= rhs;
                }
                return lhs;
            }
            long long parseTerm() {
                long long lhs = parseFactor();
                while (peek() == '*') {
                    char op = next();
                    long long rhs = parseFactor();
                    if (op == '*') lhs *= rhs;
                }
                return lhs;
            }
            long long parseFactor() {
                if (peek() == '(') {
                    next(); 
                    long long val = parseExpression();
                    if (peek() == ')') next(); 
                    return val;
                }
                std::string numStr;
                while (isdigit(peek())) numStr += next();
                if (numStr.empty()) return 0;
                try { return std::stoll(numStr); } catch (...) { return 0; }
            }
        };
        Parser p { expr.c_str() };
        return p.parseExpression();
    }
    catch (...) { return 0; }
}

int RegistrationManager::getMachineIDNumber()
{
    juce::String hex = getSystemVolumeSerial();
    if (hex.length() < 5) hex = hex.paddedRight('0', 5);
    hex = hex.substring(0, 5);
    
    juce::String numericStr = "";
    for (int i = 0; i < hex.length(); ++i)
    {
        juce::juce_wchar c = hex[i];
        char val = '0';
        switch (c) {
            case 'A': val = '1'; break; case 'B': val = '2'; break; case 'C': val = '3'; break;
            case 'D': val = '4'; break; case 'E': val = '5'; break; case 'F': val = '6'; break;
            case 'G': val = '7'; break; case 'H': val = '8'; break; case 'I': val = '9'; break;
            case 'J': val = '0'; break; case 'K': val = '2'; break; case 'L': val = '3'; break;
            case 'M': val = '4'; break; case 'N': val = '5'; break; case 'O': val = '6'; break;
            case 'P': val = '7'; break; case '1': val = '8'; break; case '2': val = '9'; break; 
            case '3': val = '2'; break; case '4': val = '1'; break; case '5': val = '3'; break; 
            case '6': val = '4'; break; case '7': val = '5'; break; case '8': val = '6'; break; 
            case '9': val = '7'; break; case '0': val = '8'; break;
            case 'Q': val = '8'; break; case 'R': val = '9'; break; case 'S': val = '2'; break;
            case 'T': val = '1'; break; case 'U': val = '2'; break; case 'V': val = '3'; break;
            case 'W': val = '4'; break; case 'X': val = '5'; break; case 'Y': val = '6'; break;
            case 'Z': val = '7'; break; default: val = '0'; break;
        }
        numericStr += val;
    }
    if (numericStr.isEmpty()) return 12345;
    return numericStr.getIntValue();
}

juce::String RegistrationManager::getSystemVolumeSerial()
{
    #if JUCE_WINDOWS
        DWORD serialNum = 0;
        if (GetVolumeInformationW(L"C:\\", nullptr, 0, &serialNum, nullptr, nullptr, nullptr, 0))
        {
            return juce::String::toHexString((int)serialNum).toUpperCase();
        }
        return "00000";
    #elif JUCE_LINUX
        std::ifstream file("/etc/machine-id");
        if (file.is_open()) {
            std::string line;
            if (std::getline(file, line)) {
                return juce::String(line).substring(0, 8).toUpperCase();
            }
        }
        return "LINUX01";
    #else
        return "MAC0001";
    #endif
}



--------------------------------------------------------------------------------
File: src/RegistrationManager.h
Size: 1.12 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  Cleaned up unnecessary inclusions. 2.  Added `decodeMidiToString` and `noteToChar` helpers. <!-- end list -->

#pragma once
#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>

class RegistrationManager
{
public:
    static RegistrationManager& getInstance() {
        static RegistrationManager instance;
        return instance;
    }

    // Main Check
    void checkRegistration();
    bool isProMode() const { return isRegistered; }

    // User Action
    bool tryRegister(const juce::String& serialInput);
    juce::String getMachineIDString(); 

private:
    RegistrationManager() = default;
    ~RegistrationManager() = default;
    bool isRegistered = false;
    
    // Core Logic
    long long calculateExpectedSerial();
    long long evaluateFormula(const juce::String& formula);
    
    // MIDI Steganography Helpers
    juce::String decodeMidiToString(const void* data, size_t size);
    char noteToChar(int note);

    // Hardware ID
    int getMachineIDNumber();
    juce::String getSystemVolumeSerial();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(RegistrationManager)
};



--------------------------------------------------------------------------------
File: src/UI/DebugConsole.h
Size: 3.02 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class DebugConsole : public juce::Component,
                     public juce::Logger
{
public:
    DebugConsole()
    {
        addAndMakeVisible(clearButton);
        clearButton.setButtonText("Clear");
        clearButton.onClick = [this]() { clearLog(); };
        
        addAndMakeVisible(logText);
        logText.setMultiLine(true);
        logText.setReadOnly(true);
        logText.setCaretVisible(false);
        logText.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFF1A1A1A));
        logText.setColour(juce::TextEditor::textColourId, juce::Colours::white);
        logText.setColour(juce::TextEditor::highlightColourId, juce::Colour(0xFFD4AF37));
        logText.setFont(juce::Font(juce::Font::getDefaultMonospacedFontName(), 12.0f, juce::Font::plain));
        
        // Set this as the global logger
        juce::Logger::setCurrentLogger(this);
        
        juce::Logger::writeToLog("=== Debug Console Initialized ===");
    }
    
    ~DebugConsole() override
    {
        // Remove as logger before destruction
        if (juce::Logger::getCurrentLogger() == this)
            juce::Logger::setCurrentLogger(nullptr);
    }
    
    void resized() override
    {
        auto area = getLocalBounds();
        auto buttonArea = area.removeFromTop(30);
        clearButton.setBounds(buttonArea.removeFromRight(80).reduced(5));
        logText.setBounds(area);
    }
    
    void logMessage(const juce::String& message) override
    {
        // THREAD SAFE: Use weak reference to avoid accessing deleted component
        juce::Component::SafePointer<DebugConsole> safeThis(this);
        
        juce::MessageManager::callAsync([safeThis, msg = juce::String(message)]() {
            // Check if component still exists
            if (safeThis == nullptr)
                return;
                
            juce::String timestamp = juce::Time::getCurrentTime().formatted("%H:%M:%S.%ms");
            juce::String formattedMessage = "[" + timestamp + "] " + msg + "\n";
            
            // Append text
            safeThis->logText.moveCaretToEnd();
            safeThis->logText.insertTextAtCaret(formattedMessage);
            
            // Auto-scroll to bottom
            safeThis->logText.moveCaretToEnd();
            
            // Limit log size to prevent memory issues (keep last 10000 chars)
            if (safeThis->logText.getTotalNumChars() > 10000)
            {
                safeThis->logText.setCaretPosition(0);
                safeThis->logText.setHighlightedRegion(juce::Range<int>(0, safeThis->logText.getTotalNumChars() - 8000));
                safeThis->logText.insertTextAtCaret("");
                safeThis->logText.moveCaretToEnd();
            }
        });
    }
    
    void clearLog()
    {
        logText.clear();
        juce::Logger::writeToLog("=== Debug Console Cleared ===");
    }
    
private:
    juce::TextButton clearButton;
    juce::TextEditor logText;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DebugConsole)
};




--------------------------------------------------------------------------------
File: src/UI/DualHandleSlider.h
Size: 4.93 KB
--------------------------------------------------------------------------------

// **Changes:** The text drawing logic was already there, but I've slightly adjusted the Y offset to ensure it doesn't get clipped and uses a distinct font.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"

class DualHandleSlider : public juce::Component
{
public:
    DualHandleSlider() { setInterceptsMouseClicks(true, false); }
    
    void setRange(double minimum, double maximum) { minValue = minimum; maxValue = maximum; }
    void setLeftValue(double value) { 
        leftValue = juce::jlimit(minValue, maxValue, value);
        if (leftValue > rightValue - 100.0) leftValue = rightValue - 100.0; 
        repaint();
    }
    void setRightValue(double value) { 
        rightValue = juce::jlimit(minValue, maxValue, value);
        if (rightValue < leftValue + 100.0) rightValue = leftValue + 100.0; 
        repaint();
    }
    double getLeftValue() const { return leftValue; }
    double getRightValue() const { return rightValue; }
    
    void setLeftMidiInfo(const juce::String& info) { leftMidiInfo = info; }
    void setRightMidiInfo(const juce::String& info) { rightMidiInfo = info; }
    
    std::function<void()> onLeftValueChange;
    std::function<void()> onRightValueChange;
    bool isUserDragging() const { return isMouseOverOrDragging() && isMouseButtonDown(); }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        float trackY = bounds.getCentreY() - 10; // Shift track up slightly to make room for text
        float trackHeight = 6.0f;
        
        g.setColour(juce::Colour(0xFF202020));
        g.fillRoundedRectangle(bounds.getX(), trackY - trackHeight/2, bounds.getWidth(), trackHeight, trackHeight/2);
        
        float leftPos = valueToPosition(leftValue);
        float rightPos = valueToPosition(rightValue);
        
        g.setColour(juce::Colour(0xFF4A90E2));
        g.fillRoundedRectangle(bounds.getX(), trackY - trackHeight/2, leftPos - bounds.getX(), trackHeight, trackHeight/2);
        g.setColour(juce::Colour(0xFF7ED321));
        g.fillRoundedRectangle(leftPos, trackY - trackHeight/2, rightPos - leftPos, trackHeight, trackHeight/2);
        g.setColour(juce::Colour(0xFFD0021B));
        g.fillRoundedRectangle(rightPos, trackY - trackHeight/2, bounds.getRight() - rightPos, trackHeight, trackHeight/2);
        
        drawHandle(g, leftPos, trackY, true);
        drawHandle(g, rightPos, trackY, false);
        
        // FIX: Ensure text is distinct
        g.setColour(juce::Colours::white);
        g.setFont(14.0f);
        // Position text clearly below handles
        g.drawText(formatFrequency(leftValue), (int)(leftPos - 30), (int)(trackY + 20), 60, 20, juce::Justification::centred);
        g.drawText(formatFrequency(rightValue), (int)(rightPos - 30), (int)(trackY + 20), 60, 20, juce::Justification::centred);
    }
    
    void mouseDown(const juce::MouseEvent& e) override
    {
        float clickX = (float)e.getPosition().getX();
        float leftPos = valueToPosition(leftValue);
        float rightPos = valueToPosition(rightValue);
        draggingLeft = (std::abs(clickX - leftPos) < std::abs(clickX - rightPos));
        if (e.mods.isRightButtonDown()) {
            if (draggingLeft && !leftMidiInfo.isEmpty()) showMidiTooltip(this, leftMidiInfo);
            else if (!draggingLeft && !rightMidiInfo.isEmpty()) showMidiTooltip(this, rightMidiInfo);
            return;
        }
        mouseDrag(e);
    }
    
    void mouseDrag(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown()) return;
        float val = positionToValue((float)e.getPosition().getX());
        if (draggingLeft) { setLeftValue(val); if (onLeftValueChange) onLeftValueChange(); }
        else { setRightValue(val); if (onRightValueChange) onRightValueChange(); }
    }
    
private:
    double minValue = 20.0, maxValue = 20000.0, leftValue = 300.0, rightValue = 3000.0;
    bool draggingLeft = false;
    juce::String leftMidiInfo, rightMidiInfo;
    
    void drawHandle(juce::Graphics& g, float x, float y, bool isLeft)
    {
        g.setColour(juce::Colours::black);
        g.fillEllipse(x - 18, y - 18, 36, 36);
        g.setColour(juce::Colour(0xFFD4AF37)); g.fillEllipse(x - 10.8f, y - 10.8f, 21.6f, 21.6f);
    }
    
    float valueToPosition(double value) const {
        double p = (value - minValue) / (maxValue - minValue);
        p = std::log(1.0 + p * 9.0) / std::log(10.0);
        return getLocalBounds().getX() + (float)p * getLocalBounds().getWidth();
    }
    double positionToValue(float position) const {
        float p = (position - getLocalBounds().getX()) / getLocalBounds().getWidth();
        return minValue + ((std::pow(10.0, juce::jlimit(0.0f, 1.0f, p)) - 1.0) / 9.0) * (maxValue - minValue);
    }
    juce::String formatFrequency(double f) const { return f >= 1000.0 ?
        juce::String(f/1000.0, 1) + " kHz" : juce::String((int)f) + " Hz"; }
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DualHandleSlider)
};



--------------------------------------------------------------------------------
File: src/UI/EffectToggleButton.h
Size: 2.31 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  **Right-Click:** `mouseDown` checks right-click, shows tooltip, and **returns immediately**. `mouseUp` also blocks right-click to prevent toggle logic. 2.  **Visuals:** `paintButton` now uses `0xFFD4AF37` (Gold) background with **Black** text when ON. <!-- end list -->

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h" 

class EffectToggleButton : public juce::ToggleButton
{
public:
    EffectToggleButton()
    {
        setButtonText("");
        setToggleState(true, juce::dontSendNotification);
    }
    
    void setMidiInfo(const juce::String& info) { midiInfo = info; }

    void mouseDown(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown())
        {
            if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo);
            return; // STRICT BLOCK: Do not call base class
        }
        juce::ToggleButton::mouseDown(e);
    }

    void mouseUp(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown())
        {
            return; // STRICT BLOCK
        }
        juce::ToggleButton::mouseUp(e);
    }

    void mouseDrag(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown()) return;
        juce::ToggleButton::mouseDrag(e);
    }
    
    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto bounds = getLocalBounds().toFloat();
        float size = juce::jmin(bounds.getWidth(), bounds.getHeight());
        auto squareBounds = bounds.withSizeKeepingCentre(size, size);
        
        bool isOn = getToggleState();
        
        // FIX: ON = Gold Background, OFF = Dark Grey
        g.setColour(isOn ? juce::Colour(0xFFD4AF37) : juce::Colour(0xFF404040));
        g.fillRoundedRectangle(squareBounds, 3.0f);
        
        // Border
        g.setColour(juce::Colours::black);
        g.drawRoundedRectangle(squareBounds, 3.0f, 2.0f);
        
        // FIX: ON = Black Text, OFF = White Text
        g.setColour(isOn ? juce::Colours::black : juce::Colours::white);
        g.setFont(juce::Font(size * 0.35f, juce::Font::bold));
        g.drawText("ON", squareBounds, juce::Justification::centred);
    }
    
private:
    juce::String midiInfo;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(EffectToggleButton)
};



--------------------------------------------------------------------------------
File: src/UI/HeaderBar.cpp
Size: 4.79 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    HeaderBar.cpp
    Playlisted2

    Fix: Dynamic scaling for Playlisted2 logo (634x109) to fit header height.
  ==============================================================================
*/

#include "HeaderBar.h"
#include <juce_graphics/juce_graphics.h>
#include "BinaryData.h"
#include "RegistrationComponent.h"
#include "ManualComponent.h" 

using namespace juce;

HeaderBar::HeaderBar(AudioEngine& engine) : audioEngine(engine)
{
    // Load Fanan Logo
    fananLogo = ImageFileFormat::loadFrom(BinaryData::logo_png, BinaryData::logo_pngSize);
    
    // Load Playlisted2 Logo
    onStageLogo = ImageFileFormat::loadFrom(BinaryData::playlisted2_png, BinaryData::playlisted2_pngSize);

    addAndMakeVisible(manualButton);
    manualButton.setButtonText("Manual");
    manualButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    manualButton.setColour(TextButton::textColourOnId, Colour(0xFFD4AF37));
    manualButton.setColour(TextButton::textColourOffId, Colour(0xFFD4AF37));
    manualButton.onClick = [this]() {
        DialogWindow::LaunchOptions opt;
        opt.content.setOwned(new ManualComponent());
        opt.dialogTitle = "Playlisted User Manual";
        opt.componentToCentreAround = this;
        opt.dialogBackgroundColour = Colour(0xFF202020);
        opt.useNativeTitleBar = true;
        opt.resizable = false;
        opt.launchAsync();
    };

    addAndMakeVisible(registerButton);
    registerButton.setButtonText("REGISTER");
    registerButton.setColour(TextButton::buttonColourId, Colour(0xFF8B0000)); 
    registerButton.setColour(TextButton::textColourOffId, Colours::white);
    registerButton.onClick = [this]() { 
        DialogWindow::LaunchOptions opt;
        opt.content.setOwned(new RegistrationComponent());
        opt.dialogTitle = "Registration";
        opt.componentToCentreAround = this;
        opt.dialogBackgroundColour = Colour(0xFFE08020);
        opt.useNativeTitleBar = true;
        opt.resizable = false;
        opt.launchAsync();
    };
    
    addAndMakeVisible(modeLabel);
    modeLabel.setFont(Font(14.0f, Font::bold));
    modeLabel.setJustificationType(Justification::centredLeft);
    
    startTimer(1000);
    timerCallback();
}

void HeaderBar::timerCallback()
{
    bool isPro = RegistrationManager::getInstance().isProMode();
    if (isPro) {
        modeLabel.setText("PRO", dontSendNotification);
        modeLabel.setColour(Label::textColourId, Colours::lightgreen);
    } else {
        modeLabel.setText("FREE", dontSendNotification);
        modeLabel.setColour(Label::textColourId, Colours::red);
    }
}

void HeaderBar::paint(Graphics& g)
{
    g.fillAll(Colour(0xFF2D2D2D));

    auto area = getLocalBounds();
    int height = area.getHeight();
    
    // Draw Fanan Logo (Left)
    if (fananLogo.isValid())
    {
        int logoHeight = height - 20;
        int logoWidth = (int)(logoHeight * 2.303f);
        Rectangle<int> fananArea(55, (height - logoHeight) / 2, logoWidth, logoHeight);
        g.drawImageWithin(fananLogo, fananArea.getX(), fananArea.getY(), 
                         fananArea.getWidth(), fananArea.getHeight(),
                         RectanglePlacement::centred);
    }

    // Draw Playlisted2 Logo (Right)
    if (onStageLogo.isValid())
    {
        // FIX: Calculate aspect ratio dynamically from the 634x109 image
        float aspectRatio = (float)onStageLogo.getWidth() / (float)onStageLogo.getHeight();
        
        // Target height is 70% of the bar height (approx 42px)
        int logoHeight = (int)(height * 0.7f); 
        int logoWidth = (int)(logoHeight * aspectRatio);
        
        // Position on the right side
        int xPos = getWidth() - logoWidth - 15;
        
        Rectangle<int> logoArea(xPos, (height - logoHeight) / 2, logoWidth, logoHeight);
        g.drawImageWithin(onStageLogo, logoArea.getX(), logoArea.getY(),
                         logoArea.getWidth(), logoArea.getHeight(),
                         RectanglePlacement::centred);
    }
    
    g.setColour(Colours::black);
    g.fillRect(0, height - 1, getWidth(), 1);
}

void HeaderBar::resized()
{
    auto area = getLocalBounds();
    int height = area.getHeight();
    int buttonHeight = 30;
    int spacing = 10;
    int buttonY = (height - buttonHeight) / 2;

    int manualWidth = 80;
    int registerWidth = 80;
    int modeLabelWidth = 50;
    
    int totalCenterGroupWidth = manualWidth + registerWidth + modeLabelWidth + (spacing * 2);
    int startX = (getWidth() - totalCenterGroupWidth) / 2;

    manualButton.setBounds(startX, buttonY, manualWidth, buttonHeight);
    registerButton.setBounds(manualButton.getRight() + spacing, buttonY, registerWidth, buttonHeight);
    modeLabel.setBounds(registerButton.getRight() + spacing, buttonY, modeLabelWidth, buttonHeight);
}



--------------------------------------------------------------------------------
File: src/UI/HeaderBar.h
Size: 0.85 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    HeaderBar.h
    Playlisted2

  ==============================================================================
*/

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_graphics/juce_graphics.h>
#include "../AudioEngine.h"

class HeaderBar : public juce::Component, private juce::Timer
{
public:
    HeaderBar(AudioEngine& engine);
    ~HeaderBar() override = default;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
private:
    void timerCallback() override;

    AudioEngine& audioEngine;
    juce::Image fananLogo;
    juce::Image onStageLogo; // The product logo

    juce::TextButton manualButton;
    juce::TextButton registerButton;
    juce::Label modeLabel;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(HeaderBar)
};



--------------------------------------------------------------------------------
File: src/UI/LongPressDetector.h
Size: 1.38 KB
--------------------------------------------------------------------------------

// This is the helper class that handles the timer and distance logic.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

// A Mix-in class to add Long Press detection to any Component
class LongPressDetector : private juce::Timer
{
public:
    virtual ~LongPressDetector() { stopTimer(); }

    // Call this from your component's mouseDown
    void handleMouseDown(const juce::MouseEvent& e)
    {
        mouseDownTime = e.eventTime;
        mouseDownPos = e.getPosition();
        isLongPressTriggered = false;
        // 800ms is a standard "Long Press" duration
        startTimer(800); 
    }

    // Call this from mouseDrag
    void handleMouseDrag(const juce::MouseEvent& e)
    {
        // If user moves finger/mouse more than 10 pixels, cancel the long press
        if (e.getPosition().getDistanceFrom(mouseDownPos) > 10)
            stopTimer(); 
    }

    // Call this from mouseUp
    void handleMouseUp(const juce::MouseEvent& e)
    {
        stopTimer();
    }

    // Override this in your component to react!
    virtual void onLongPress() = 0;

private:
    void timerCallback() override
    {
        stopTimer();
        isLongPressTriggered = true;
        onLongPress();
    }

    juce::Point<int> mouseDownPos;
    juce::Time mouseDownTime;
protected:
    // Use this flag in mouseUp/mouseDrag to ignore events if long press happened
    bool isLongPressTriggered = false;
};



--------------------------------------------------------------------------------
File: src/UI/MainComponent.cpp
Size: 1.58 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    MainComponent.cpp
    Playlisted2

    VSTi Fix: Removed global LookAndFeel setting to avoid interfering with DAW
    or other plugin instances. Applied LookAndFeel locally instead.

  ==============================================================================
*/

#include "MainComponent.h"
#include "../AppLogger.h"
#include "../RegistrationManager.h"

using namespace juce;

MainComponent::MainComponent(AudioEngine& engine, IOSettingsManager& settings)
    : audioEngine(engine),
      ioSettingsManager(settings),
      header(engine)
{
    LOG_INFO("=== MainComponent UI Constructed (Linked to Processor) ===");
    
    // 1. License Check
    RegistrationManager::getInstance().checkRegistration();

    // 2. Load Settings 
    ioSettingsManager.loadSettings();

    // 3. L&F - FIX: Apply Locally for VST Safety
    goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
    setLookAndFeel(goldenLookAndFeel.get()); // Apply only to this component and children

    // 4. Add Components
    addAndMakeVisible(header);

    // 5. Create Media Page
    mediaPage = std::make_unique<MediaPage>(audioEngine, ioSettingsManager);
    addAndMakeVisible(mediaPage.get());

    setSize(1000, 700);
}

MainComponent::~MainComponent()
{
    setLookAndFeel(nullptr);
}

void MainComponent::paint(Graphics& g)
{
    g.fillAll(Colour(0xFF202020));
}

void MainComponent::resized()
{
    auto area = getLocalBounds();
    header.setBounds(area.removeFromTop(60));

    if (mediaPage)
        mediaPage->setBounds(area);
}



--------------------------------------------------------------------------------
File: src/UI/MainComponent.h
Size: 0.89 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    MainComponent.h
    Playlisted2

  ==============================================================================
*/

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "../AudioEngine.h"
#include "../IOSettingsManager.h"
#include "HeaderBar.h"
#include "MediaPage.h"
#include "StyledSlider.h" 

class MainComponent : public juce::Component
{
public:
    MainComponent(AudioEngine& engine, IOSettingsManager& settings);
    ~MainComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    AudioEngine& audioEngine;
    IOSettingsManager& ioSettingsManager;
    
    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;
    HeaderBar header;
    std::unique_ptr<MediaPage> mediaPage;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainComponent)
};



--------------------------------------------------------------------------------
File: src/UI/ManualComponent.h
Size: 7.45 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class ManualComponent : public juce::Component
{
public:
    ManualComponent()
    {
        // Define Pages
        pageTitles = { 
            "1. What is Playlisted?", 
            "2. Plugin Operation", 
            "3. MIDI Support", 
            "4. Tooltips & Help", 
            "5. Registration" 
        };

        pageContents = {
            // 1. What is Playlisted?
            "WHAT IS PLAYLISTED?\n\n"
            "Welcome to Playlisted! This plugin is a unique media engine designed to run inside your DAW (Digital Audio Workstation). "
            "It bridges the gap between standard music production tools and live performance media players.\n\n"
            "What does it do?\n"
            "Playlisted allows you to load lists of audio or video files (MP3, WAV, MP4, AVI, etc.) and play them back directly "
            "through your DAW's audio engine. It handles video decoding in a separate high-performance window while keeping audio "
            "perfectly synced.\n\n"
            "Key Features:\n"
            "- Real-time Pitch Shifting: Change the key of a song (+/- 12 semitones) without affecting the speed.\n"
            "- Speed Control: Slow down or speed up practice tracks (0.1x to 2.1x).\n"
            "- Auto-Wait Logic: Set specific countdown times between tracks for seamless live sets.",

            // 2. Plugin Operation
            "PLUGIN OPERATION\n\n"
            "The Interface is divided into the Playlist (top) and the Player (bottom).\n\n"
            "1. Managing Files:\n"
            "   Use the buttons to 'Add Media Files', 'Clear', 'Save', or 'Load' playlists. You can also set a 'Default Folder' "
            "to open your favorite directory quickly.\n\n"
            "2. Track Controls (The Banner):\n"
            "   Each track has an expansion arrow ('v'). Click it to reveal advanced controls:\n"
            "   - Vol: Individual track volume.\n"
            "   - Pitch: Shift the key up or down by 12 semitones.\n"
            "   - Speed: Change playback rate.\n"
            "   - Wait: Set a delay (in seconds). When the track ends, Playlisted will count down this duration before automatically "
            "starting the next track.\n\n"
            "3. Playback:\n"
            "   Click the Green Triangle on any track to load and select it. Use the main PLAY/STOP buttons at the bottom to control playback.\n\n"
            "4. Video:\n"
            "   If you load a video file, click 'SHOW VIDEO' to open the projection window.",

            // 3. MIDI Support
            "MIDI SUPPORT\n\n"
            "Playlisted is designed for hands-free control using any MIDI keyboard or controller.\n\n"
            "Fixed Mappings:\n"
            "- Note 15: Play / Pause toggle.\n"
            "- Note 16: Stop (and return to zero).\n"
            "- Note 17: Show / Hide the Video Window.\n\n"
            "Setup:\n"
            "Simply route a MIDI track in your DAW to the Playlisted plugin. Ensure your controller is sending on MIDI Channel 1 (or Omni).",

            // 4. Tooltips & Help
            "TOOLTIPS & HELP\n\n"
            "Unsure what a specific button or slider does?\n\n"
            "Just RIGHT-CLICK on it!\n\n"
            "Almost every control in Playlisted has a built-in help bubble. Right-clicking will show you the control's name, "
            "its current value, and any MIDI notes assigned to it.\n\n"
            "This works on the main buttons, the sliders inside the playlist, and even the header buttons.",

            // 5. Registration
            "REGISTRATION\n\n"
            "Playlisted operates in two modes:\n\n"
            "1. FREE Mode:\n"
            "   Fully functional, but limited to a maximum of 3 tracks per playlist. You can use all features (Pitch, Video, Speed), "
            "but you cannot add a 4th file.\n\n"
            "2. PRO Mode:\n"
            "   Unlimited tracks and playlists.\n\n"
            "How to Upgrade:\n"
            "1. Click the 'REGISTER' button in the top header.\n"
            "2. Copy your 'User ID' and send it to us / enter it on the website.\n"
            "3. Paste the 'Serial Number' you receive back into the box.\n"
            "4. Click 'Save License File'.\n\n"
            "Thank you for supporting independent audio development!"
        };

        // Create Navigation Buttons
        for (int i = 0; i < pageTitles.size(); ++i)
        {
            auto* btn = new juce::TextButton();
            btn->setButtonText(juce::String(i + 1));
            btn->setTooltip(pageTitles[i]); // Hover to see page name
            btn->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
            btn->setColour(juce::TextButton::textColourOffId, juce::Colours::white);
            btn->onClick = [this, i] { setPage(i); };
            addAndMakeVisible(btn);
            navButtons.add(btn);
        }

        // Title Header
        addAndMakeVisible(pageHeaderLabel);
        pageHeaderLabel.setFont(juce::Font(22.0f, juce::Font::bold));
        pageHeaderLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37)); // Gold
        pageHeaderLabel.setJustificationType(juce::Justification::centred);

        // Content Area
        addAndMakeVisible(contentView);
        contentView.setMultiLine(true);
        contentView.setReadOnly(true);
        contentView.setCaretVisible(false);
        contentView.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFF151515));
        contentView.setColour(juce::TextEditor::textColourId, juce::Colours::white);
        contentView.setColour(juce::TextEditor::outlineColourId, juce::Colours::transparentBlack);
        contentView.setFont(juce::Font(16.0f));

        setSize(600, 500);
        setPage(0); // Load Page 1
    }

    void paint(juce::Graphics& g) override
    {
        g.fillAll(juce::Colour(0xFF202020)); // Background
    }

    void resized() override
    {
        auto area = getLocalBounds().reduced(15);
        // Navigation Bar
        auto navArea = area.removeFromTop(30);
        int btnWidth = navArea.getWidth() / navButtons.size();
        for (auto* btn : navButtons)
        {
            btn->setBounds(navArea.removeFromLeft(btnWidth).reduced(2, 0));
        }

        area.removeFromTop(10);
        
        // Page Title
        pageHeaderLabel.setBounds(area.removeFromTop(30));
        // Content
        area.removeFromTop(10);
        contentView.setBounds(area);
    }

private:
    void setPage(int index)
    {
        if (index < 0 || index >= pageTitles.size()) return;
        // Update Buttons Visuals
        for (int i = 0; i < navButtons.size(); ++i)
        {
            if (i == index) {
                navButtons[i]->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFFD4AF37)); // Gold
                navButtons[i]->setColour(juce::TextButton::textColourOffId, juce::Colours::black);
            } else {
                navButtons[i]->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A)); // Dark
                navButtons[i]->setColour(juce::TextButton::textColourOffId, juce::Colours::white);
            }
        }

        // Update Text
        pageHeaderLabel.setText(pageTitles[index], juce::dontSendNotification);
        contentView.setText(pageContents[index]);
        contentView.moveCaretToTop(false);
    }

    juce::StringArray pageTitles;
    juce::StringArray pageContents;
    juce::OwnedArray<juce::TextButton> navButtons;
    juce::Label pageHeaderLabel;
    juce::TextEditor contentView;
};



--------------------------------------------------------------------------------
File: src/UI/MediaPage.cpp
Size: 6.78 KB
--------------------------------------------------------------------------------

#include "MediaPage.h"

// NEW: Subclass for Show Video Button to add Tooltip and Black Text
class ShowVideoButton : public juce::TextButton, public LongPressDetector
{
public:
    ShowVideoButton() : juce::TextButton("SHOW VIDEO") 
    {
        setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF4A90E2)); 
        setColour(juce::TextButton::textColourOffId, juce::Colours::black); 
        setTooltip("Opens the video window if closed");
    }

    void onLongPress() override 
    {
        showMidiTooltip(this, "Show Video Window\nMIDI: Note 17");
    }

    void mouseDown(const juce::MouseEvent& e) override 
    { 
        if (e.mods.isRightButtonDown()) { onLongPress(); return; }
        handleMouseDown(e); 
        juce::TextButton::mouseDown(e); 
    }
    void mouseUp(const juce::MouseEvent& e) override { handleMouseUp(e); if (e.mods.isRightButtonDown() || isLongPressTriggered) return; juce::TextButton::mouseUp(e); }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::TextButton::mouseDrag(e); }
};

MediaPage::MediaPage(AudioEngine& engine, IOSettingsManager& settings) : audioEngine(engine),
    progressSlider(juce::Slider::LinearBar, juce::Slider::NoTextBox) 
{
    playlistComponent = std::make_unique<PlaylistComponent>(engine, settings);
    addAndMakeVisible(playlistComponent.get());

    addAndMakeVisible(playPauseBtn);
    playPauseBtn.setButtonText("PLAY");
    playPauseBtn.setMidiInfo("MIDI: Note 15");
    playPauseBtn.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
    playPauseBtn.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
    playPauseBtn.onClick = [this] { 
        auto& player = audioEngine.getMediaPlayer();
        if (player.isPlaying()) player.pause();
        else player.play();
    };

    addAndMakeVisible(stopBtn);
    stopBtn.setButtonText("STOP");
    stopBtn.setMidiInfo("MIDI: Note 16");
    stopBtn.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
    stopBtn.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
    stopBtn.onClick = [this] { 
        audioEngine.stopAllPlayback();
        playPauseBtn.setButtonText("PLAY");
        progressSlider.setValue(0.0, juce::dontSendNotification);
    };

    // Use new button class
    showVideoBtn = std::make_unique<ShowVideoButton>();
    addAndMakeVisible(showVideoBtn.get());
    showVideoBtn->onClick = [this] { 
        audioEngine.showVideoWindow();
    };

    addAndMakeVisible(progressSlider);
    progressSlider.setRange(0.0, 1.0, 0.001);
    progressSlider.setColour(juce::Slider::trackColourId, juce::Colour(0xFFD4AF37));
    progressSlider.setColour(juce::Slider::backgroundColourId, juce::Colour(0xFF404040));
    progressSlider.onDragStart = [this] { isUserDraggingSlider = true; };
    progressSlider.onDragEnd = [this] { 
        isUserDraggingSlider = false;
        audioEngine.getMediaPlayer().setPosition((float)progressSlider.getValue());
    };
    progressSlider.onValueChange = [this] {
        if (isUserDraggingSlider) audioEngine.getMediaPlayer().setPosition((float)progressSlider.getValue());
    };

    addAndMakeVisible(currentTimeLabel);
    currentTimeLabel.setText("00:00", juce::dontSendNotification);
    currentTimeLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    currentTimeLabel.setJustificationType(juce::Justification::centredRight);
    currentTimeLabel.setFont(juce::Font(16.0f, juce::Font::bold));

    addAndMakeVisible(totalTimeLabel);
    totalTimeLabel.setText("00:00", juce::dontSendNotification);
    totalTimeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    totalTimeLabel.setJustificationType(juce::Justification::centredLeft);
    totalTimeLabel.setFont(juce::Font(16.0f, juce::Font::bold));

    addAndMakeVisible(countdownLabel);
    countdownLabel.setText("", juce::dontSendNotification);
    countdownLabel.setColour(juce::Label::textColourId, juce::Colours::red);
    countdownLabel.setJustificationType(juce::Justification::centred); 
    countdownLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    startTimerHz(30);
}

MediaPage::~MediaPage() { stopTimer(); }

juce::String MediaPage::formatTime(double seconds) const
{
    if (seconds < 0) seconds = 0;
    int totalSeconds = (int)seconds;
    int m = totalSeconds / 60;
    int s = totalSeconds % 60;
    return juce::String::formatted("%02d:%02d", m, s);
}

void MediaPage::timerCallback()
{
    auto& player = audioEngine.getMediaPlayer();
    bool isPlaying = player.isPlaying();
    playPauseBtn.setButtonText(isPlaying ? "PAUSE" : "PLAY");
    playPauseBtn.setColour(juce::TextButton::textColourOffId, isPlaying ? juce::Colour(0xFFD4AF37) : juce::Colours::white);

    // NEW: Visibility Check for Video Button
    if (showVideoBtn)
        showVideoBtn->setVisible(!player.isWindowOpen());

    if (!isUserDraggingSlider && isPlaying)
    {
        progressSlider.setValue(player.getPosition(), juce::dontSendNotification);
    }

    double lenMs = (double)player.getLengthMs();
    double posRatio = player.getPosition();
    double currentMs = lenMs * posRatio;

    totalTimeLabel.setText(formatTime(lenMs / 1000.0), juce::dontSendNotification);
    currentTimeLabel.setText(formatTime(currentMs / 1000.0), juce::dontSendNotification);

    int remaining = playlistComponent->getWaitSecondsRemaining();
    if (remaining > 0)
    {
        countdownLabel.setText("Next track in: " + juce::String(remaining), juce::dontSendNotification);
        countdownLabel.setVisible(true);
    }
    else
    {
        countdownLabel.setVisible(false);
    }
}

void MediaPage::paint(juce::Graphics& g) 
{ 
    g.fillAll(juce::Colour(0xFF202020));
}

void MediaPage::resized()
{
    auto area = getLocalBounds();
    auto transportArea = area.removeFromBottom(60); 
    transportArea.removeFromTop(5); 

    auto countdownArea = area.removeFromBottom(25);
    countdownLabel.setBounds(countdownArea);

    int btnHeight = 40;
    int btnY = (transportArea.getHeight() - btnHeight) / 2;
    int startX = 5;
    int spacing = 10;
    int btnW = 80;
    int videoBtnW = 100;

    playPauseBtn.setBounds(startX, transportArea.getY() + btnY, btnW, btnHeight);
    stopBtn.setBounds(playPauseBtn.getRight() + spacing, transportArea.getY() + btnY, btnW, btnHeight);
    
    // Position show video button
    if (showVideoBtn)
        showVideoBtn->setBounds(stopBtn.getRight() + spacing, transportArea.getY() + btnY, videoBtnW, btnHeight);

    int clockW = 60;
    totalTimeLabel.setBounds(transportArea.removeFromRight(clockW));
    
    auto sliderArea = transportArea;
    sliderArea.removeFromLeft(startX + btnW*2 + videoBtnW + spacing*2 + 10);
    
    currentTimeLabel.setBounds(sliderArea.removeFromLeft(clockW));
    progressSlider.setBounds(sliderArea.reduced(5, 15)); 

    playlistComponent->setBounds(area);
}



--------------------------------------------------------------------------------
File: src/UI/MediaPage.h
Size: 1.06 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include "../AudioEngine.h"
#include "../IOSettingsManager.h"
#include "PlaylistComponent.h"
#include "StyledSlider.h" 

class MediaPage : public juce::Component, private juce::Timer
{
public:
    MediaPage(AudioEngine& engine, IOSettingsManager& settings);
    ~MediaPage() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    juce::String formatTime(double seconds) const;
    AudioEngine& audioEngine;
    
    std::unique_ptr<PlaylistComponent> playlistComponent;
    
    MidiTooltipTextButton playPauseBtn;
    MidiTooltipTextButton stopBtn;
    
    // Changed to unique_ptr for custom button class
    std::unique_ptr<juce::TextButton> showVideoBtn;
    
    StyledSlider progressSlider;
    juce::Label currentTimeLabel;
    juce::Label totalTimeLabel;
    juce::Label countdownLabel;
    
    bool isUserDraggingSlider = false;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MediaPage)
};



--------------------------------------------------------------------------------
File: src/UI/PlaylistComponent.cpp
Size: 16.23 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    PlaylistComponent.cpp
    Playlisted2

  ==============================================================================
*/

#include "PlaylistComponent.h"
#include "../RegistrationManager.h"

using namespace juce;

PlaylistComponent::PlaylistComponent(AudioEngine& engine, IOSettingsManager& settings)
    : audioEngine(engine), ioSettings(settings), playlist(engine.getPlaylist()) 
{
    addAndMakeVisible(headerLabel);
    headerLabel.setText("PLAYLIST", dontSendNotification);
    headerLabel.setFont(Font(18.0f, Font::bold));
    headerLabel.setColour(Label::textColourId, Colour(0xFFD4AF37));
    headerLabel.setJustificationType(Justification::centredLeft);

    addAndMakeVisible(autoPlayToggle);
    autoPlayToggle.setButtonText("Auto-Play");
    autoPlayToggle.setToggleState(true, dontSendNotification);
    autoPlayToggle.setColour(ToggleButton::textColourId, Colours::white);
    autoPlayToggle.setColour(ToggleButton::tickColourId, Colour(0xFFD4AF37));
    autoPlayToggle.onClick = [this] { autoPlayEnabled = autoPlayToggle.getToggleState(); };

    // --- BUTTON ROW INITIALIZATION (5 Buttons) ---
    
    // 1. Add Files
    addAndMakeVisible(addTrackButton);
    addTrackButton.setButtonText("Add Media Files");
    addTrackButton.setColour(TextButton::buttonColourId, Colour(0xFF404040));
    addTrackButton.onClick = [this] {
        File startDir = File::getSpecialLocation(File::userMusicDirectory);
        String savedPath = ioSettings.getMediaFolder();
        if (savedPath.isNotEmpty()) {
            File f(savedPath);
            if (f.isDirectory()) startDir = f;
        }

        auto fc = std::make_shared<FileChooser>("Select Media Files",
            startDir,
            "*.mp3;*.wav;*.aiff;*.flac;*.ogg;*.m4a;*.mp4;*.avi;*.mov;*.mkv;*.webm;*.mpg;*.mpeg", true);

        fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectMultipleItems,
            [this, fc](const FileChooser& chooser) {
                auto results = chooser.getResults();
                for (auto& file : results)
                    addTrack(file);
            });
    };

    // 2. Clear
    addAndMakeVisible(clearButton);
    clearButton.setButtonText("Clear Playlist");
    clearButton.setColour(TextButton::buttonColourId, Colour(0xFF8B0000));
    clearButton.onClick = [this] { clearPlaylist(); };

    // 3. Save
    addAndMakeVisible(saveButton);
    saveButton.setButtonText("Save Playlist");
    saveButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    saveButton.onClick = [this] { savePlaylist(); };

    // 4. Load
    addAndMakeVisible(loadButton);
    loadButton.setButtonText("Load Playlist");
    loadButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    loadButton.onClick = [this] { loadPlaylist(); };

    // 5. Set Folder
    addAndMakeVisible(defaultFolderButton);
    defaultFolderButton.setButtonText("Set Playlist's Folder");
    defaultFolderButton.setColour(TextButton::buttonColourId, Colour(0xFF404040));
    defaultFolderButton.onClick = [this] { setDefaultFolder(); };

    addAndMakeVisible(viewport);
    viewport.setScrollBarsShown(true, false);
    viewport.setViewedComponent(&listContainer, false);

    rebuildList();
    
    // [FIX] SMART RESTORE: Check if we have a persisted track index from the engine
    int savedIndex = audioEngine.getActiveTrackIndex();
    if (!playlist.empty())
    {
        if (savedIndex >= 0 && savedIndex < (int)playlist.size())
        {
            // Restore visual selection ONLY (Do NOT call selectTrack(index) because it triggers loadFile)
            currentTrackIndex = savedIndex;
            updateBannerVisuals();
            scrollToBanner(currentTrackIndex);
        }
        else
        {
            // First run or invalid state -> Default to 0 and load it
            currentTrackIndex = 0;
            selectTrack(0);
        }
    }

    startTimerHz(30);
}

PlaylistComponent::~PlaylistComponent()
{
    stopTimer();
    banners.clear();
}

void PlaylistComponent::paint(Graphics& g)
{
    g.fillAll(Colour(0xFF222222));
}

void PlaylistComponent::resized()
{
    auto area = getLocalBounds().reduced(12);
    auto row1 = area.removeFromTop(35);
    headerLabel.setBounds(row1.removeFromLeft(120).reduced(5, 0));
    autoPlayToggle.setBounds(row1.removeFromRight(100).reduced(5, 0));

    // Button Row: 5 buttons evenly spaced
    auto row2 = area.removeFromTop(40);
    int numButtons = 5;
    int spacing = 4;
    int totalSpacing = (numButtons - 1) * spacing;
    int btnWidth = (row2.getWidth() - totalSpacing) / numButtons;

    addTrackButton.setBounds(row2.removeFromLeft(btnWidth));
    row2.removeFromLeft(spacing);
    clearButton.setBounds(row2.removeFromLeft(btnWidth));
    row2.removeFromLeft(spacing);
    saveButton.setBounds(row2.removeFromLeft(btnWidth));
    row2.removeFromLeft(spacing);
    loadButton.setBounds(row2.removeFromLeft(btnWidth));
    row2.removeFromLeft(spacing);
    defaultFolderButton.setBounds(row2.removeFromLeft(btnWidth));
    
    viewport.setBounds(area);
    rebuildList();
}

void PlaylistComponent::setDefaultFolder()
{
    auto fc = std::make_shared<FileChooser>("Choose Default Media Folder",
        File::getSpecialLocation(File::userMusicDirectory));

    fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectDirectories,
        [this, fc](const FileChooser& chooser) {
            auto result = chooser.getResult();
            if (result.isDirectory()) {
                ioSettings.saveMediaFolder(result.getFullPathName());
                NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, "Success", 
                    "Default media folder set to:\n" + result.getFileName());
            }
        });
}

void PlaylistComponent::addTrack(const File& file)
{
    if (!RegistrationManager::getInstance().isProMode() && playlist.size() >= 3)
    {
        NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, 
            "Free Mode", 
            "Free Mode is limited to 3 tracks maximum.\n\nPlease click 'REGISTER' to unlock Pro Mode and unlimited tracks.");
        return;
    }

    PlaylistItem item;
    item.filePath = file.getFullPathName();
    item.title = file.getFileNameWithoutExtension();
    item.volume = 1.0f;
    item.playbackSpeed = 1.0f;
    item.pitchSemitones = 0;
    item.transitionDelaySec = 0;
    item.isCrossfade = false; 
    
    playlist.push_back(item);
    
    // Default Selection Logic: If first track, select it.
    if (playlist.size() == 1)
    {
        currentTrackIndex = 0;
        selectTrack(0);
    }
    
    rebuildList();
}

void PlaylistComponent::clearPlaylist()
{
    playlist.clear();
    banners.clear();
    currentTrackIndex = -1;
    audioEngine.setActiveTrackIndex(-1);
    // [FIX] Clear engine state too
    waitingForTransition = false;
    audioEngine.stopAllPlayback();
    rebuildList();
}

void PlaylistComponent::removeTrack(int index)
{
    if (index >= 0 && index < (int)playlist.size())
    {
        playlist.erase(playlist.begin() + index);

        if (currentTrackIndex == index) 
        {
            currentTrackIndex = -1;
            audioEngine.setActiveTrackIndex(-1);
            waitingForTransition = false;
            audioEngine.stopAllPlayback();
        }
        else if (currentTrackIndex > index)
        {
            currentTrackIndex--;
            audioEngine.setActiveTrackIndex(currentTrackIndex); // Sync decrement
        }
        rebuildList();
    }
}

void PlaylistComponent::selectTrack(int index)
{
    if (index < 0 || index >= (int)playlist.size()) return;
    
    currentTrackIndex = index;
    audioEngine.setActiveTrackIndex(index);
    // [FIX] Persist selection to Engine
    
    waitingForTransition = false;
    
    auto& item = playlist[index];
    if (audioEngine.getMediaPlayer().loadFile(item.filePath))
    {
        audioEngine.getMediaPlayer().setVolume(item.volume);
        audioEngine.getMediaPlayer().setRate(item.playbackSpeed);
        audioEngine.setPitchSemitones(item.pitchSemitones);
    }
    
    updateBannerVisuals();
}

void PlaylistComponent::playTrack(int index)
{
    selectTrack(index); 
    audioEngine.getMediaPlayer().play();
}

void PlaylistComponent::scrollToBanner(int index)
{
    if (index < 0 || index >= banners.size()) return;
    if (auto* banner = banners[index])
    {
        viewport.setViewPosition(0, banner->getY());
    }
}

void PlaylistComponent::rebuildList()
{
    banners.clear();
    listContainer.removeAllChildren();
    
    int y = 0;
    for (size_t i = 0; i < playlist.size(); ++i)
    {
        auto& item = playlist[i];
        int currentH = item.isExpanded ? 170 : 44; 
        
        auto* banner = new TrackBannerComponent((int)i, item, 
            [this, i] { removeTrack((int)i); }, 
            [this, i] { 
                playlist[i].isExpanded = !playlist[i].isExpanded; 
                rebuildList(); 
            }, 
            // FIX: TRIANGLE CLICK (LOAD ONLY)
            // The green triangle now STRICTLY selects/loads the track.
            // It will NEVER start playback, ensuring Play/Stop buttons have exclusive transport control.
            [this, i] { 
                selectTrack((int)i);
            }, 
            [this, i](float vol) { 
                if (currentTrackIndex == (int)i) 
                    audioEngine.getMediaPlayer().setVolume(vol);
            },
            [this, i](int semitones) {
                if (currentTrackIndex == (int)i)
                    audioEngine.setPitchSemitones(semitones);
            },
            [this, i](float speed) {
                if (currentTrackIndex == (int)i) 
                    audioEngine.getMediaPlayer().setRate(speed);
            }
        );

        banner->setBounds(0, y, viewport.getWidth(), currentH);
        listContainer.addAndMakeVisible(banner);
        banners.add(banner);
        
        y += currentH + 2;
    }
    
    listContainer.setSize(viewport.getWidth(), y + 50);
    updateBannerVisuals();
}

void PlaylistComponent::updateBannerVisuals()
{
    for (int i = 0; i < banners.size(); ++i)
    {
        bool isCurrent = (i == currentTrackIndex);
        banners[i]->setPlaybackState(isCurrent, audioEngine.getMediaPlayer().isPlaying());
    }
}

void PlaylistComponent::timerCallback()
{
    if ((int)playlist.size() != banners.size())
    {
        rebuildList();
        // ENSURE DEFAULT SELECTION
        if (currentTrackIndex == -1 && !playlist.empty())
        {
            currentTrackIndex = 0;
            selectTrack(0);
        }
    }

    if (autoPlayEnabled && currentTrackIndex >= 0 && currentTrackIndex < (int)playlist.size())
    {
        auto& player = audioEngine.getMediaPlayer();
        bool hasFinished = player.hasFinished();
        
        if (waitingForTransition)
        {
            if (transitionCountdown > 0)
            {
                transitionCountdown--;
            }
            else
            {
                waitingForTransition = false;
                int nextIndex = currentTrackIndex + 1;
                if (nextIndex < (int)playlist.size())
                {
                    playTrack(nextIndex);
                    if (autoPlayEnabled) scrollToBanner(nextIndex);
                }
                else
                {
                    audioEngine.stopAllPlayback();
                }
            }
            finishDebounceCounter = 0;
        }
        else if (hasFinished) 
        {
            finishDebounceCounter++;
            if (finishDebounceCounter > 6)
            {
                auto& currentItem = playlist[currentTrackIndex];
                int nextIndex = currentTrackIndex + 1;
                
                if (nextIndex < (int)playlist.size())
                {
                    waitingForTransition = true;
                    player.pause(); 

                    int sec = currentItem.transitionDelaySec;
                    transitionCountdown = (sec > 0) ? (sec * 30) : 15;
                }
            }
        }
        else
        {
            finishDebounceCounter = 0;
        }
    }
    updateBannerVisuals();
}

void PlaylistComponent::savePlaylist()
{
    auto fc = std::make_shared<FileChooser>("Save Playlist",
        File::getSpecialLocation(File::userDocumentsDirectory), "*.json");

    fc->launchAsync(FileBrowserComponent::saveMode | FileBrowserComponent::canSelectFiles,
        [this, fc](const FileChooser& chooser) {
            auto file = chooser.getResult();
            if (file == File{}) return; 

            if (!file.hasFileExtension("json"))
                file = file.withFileExtension("json");

            DynamicObject::Ptr root = new DynamicObject();
            Array<var> tracks;
            
            for (const auto& item : playlist)
            {
                DynamicObject::Ptr obj = new DynamicObject();
                obj->setProperty("path", item.filePath);
                obj->setProperty("title", item.title);
                obj->setProperty("vol", item.volume);
                obj->setProperty("pitch", item.pitchSemitones);
                obj->setProperty("speed", item.playbackSpeed);
                obj->setProperty("delay", item.transitionDelaySec);
                obj->setProperty("xfade", item.isCrossfade);
                tracks.add(obj.get());
            }

            root->setProperty("tracks", tracks);
            if (file.replaceWithText(JSON::toString(var(root.get()))))
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, "Success", 
                    "Playlist saved successfully!");
            }
            else
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::WarningIcon, "Error", 
                    "Could not write to file.");
            }
        });
}

void PlaylistComponent::loadPlaylist()
{
    auto fc = std::make_shared<FileChooser>("Load Playlist",
        File::getSpecialLocation(File::userDocumentsDirectory), "*.json");

    fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectFiles,
        [this, fc](const FileChooser& chooser) {
            auto file = chooser.getResult();
            if (!file.existsAsFile()) return;
            
            var json = JSON::parse(file);
            if (auto* root = json.getDynamicObject())
            {
                if (auto* tracks = root->getProperty("tracks").getArray())
                {
                    clearPlaylist();
                    
                    bool isPro = RegistrationManager::getInstance().isProMode();
                    int max = isPro ? 99999 : 3;
                    int count = 0;
                    
                    for (auto& t : *tracks)
                    {
                        if (count >= max) break;
                        
                        if (auto* obj = t.getDynamicObject())
                        {
                            PlaylistItem item;
                            item.filePath = obj->getProperty("path").toString();
                            if (obj->hasProperty("title"))
                                item.title = obj->getProperty("title").toString();
                            else
                                item.ensureTitle();
                            
                            if (File(item.filePath).existsAsFile())
                            {
                                item.volume = (float)obj->getProperty("vol");
                                if (obj->hasProperty("pitch")) item.pitchSemitones = (int)obj->getProperty("pitch");
                                item.playbackSpeed = (float)obj->getProperty("speed");
                                item.transitionDelaySec = (int)obj->getProperty("delay");
                                item.isCrossfade = (bool)obj->getProperty("xfade");
                                playlist.push_back(item);
                                count++;
                            }
                        }
                    }
                    
                    rebuildList();
                    // Explicitly select first track after load
                    if (!playlist.empty()) selectTrack(0);
                }
            }
            else
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::WarningIcon, "Error", 
                    "Failed to parse playlist file.");
            }
        });
}



--------------------------------------------------------------------------------
File: src/UI/PlaylistComponent.h
Size: 2.08 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "PlaylistDataStructures.h"
#include "TrackBannerComponent.h"
#include "../AudioEngine.h"
#include "../IOSettingsManager.h" 

class PlaylistListContainer : public juce::Component
{
public:
    PlaylistListContainer() { setOpaque(true); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF222222)); }
};

class PlaylistComponent : public juce::Component, private juce::Timer
{
public:
    PlaylistComponent(AudioEngine& engine, IOSettingsManager& settings);
    ~PlaylistComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

    void addTrack(const juce::File& file);
    void playTrack(int index);
    void removeTrack(int index);
    void selectTrack(int index);
    void clearPlaylist();
    // Returns remaining wait time in seconds (or 0 if not waiting)
    int getWaitSecondsRemaining() const {
        if (!waitingForTransition) return 0;
        return (int)std::ceil(transitionCountdown / 30.0f);
    }

private:
    void timerCallback() override;
    void rebuildList();
    void updateBannerVisuals();
    void scrollToBanner(int index);

    void savePlaylist();
    void loadPlaylist();
    void setDefaultFolder();

    AudioEngine& audioEngine;
    IOSettingsManager& ioSettings;
    
    std::vector<PlaylistItem>& playlist; 

    int currentTrackIndex = -1;
    bool autoPlayEnabled = true;
    bool waitingForTransition = false;
    int transitionCountdown = 0;
    
    // Debounce counter for detecting track finish to prevent "Skip on Speed Change"
    int finishDebounceCounter = 0;

    juce::Label headerLabel;
    juce::ToggleButton autoPlayToggle;
    juce::TextButton defaultFolderButton; 
    juce::TextButton addTrackButton;
    juce::TextButton clearButton;
    juce::TextButton saveButton;
    juce::TextButton loadButton;

    juce::Viewport viewport;
    PlaylistListContainer listContainer;
    juce::OwnedArray<TrackBannerComponent> banners;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PlaylistComponent)
};



--------------------------------------------------------------------------------
File: src/UI/PlaylistDataStructures.h
Size: 0.53 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_core/juce_core.h>

struct PlaylistItem
{
    juce::String filePath;
    juce::String title;
    float volume = 1.0f; 
    
    // NEW: Pitch in Semitones (-12 to +12)
    int pitchSemitones = 0; 
    
    float playbackSpeed = 1.0f;
    int transitionDelaySec = 0;
    bool isCrossfade = false;
    bool isExpanded = false;

    // Helper to extract name from path if title empty
    void ensureTitle()
    {
        if (title.isEmpty())
            title = juce::File(filePath).getFileNameWithoutExtension();
    }
};



--------------------------------------------------------------------------------
File: src/UI/RegistrationComponent.h
Size: 9.47 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "../RegistrationManager.h"

// ==============================================================================
// Info Button & Tooltip Helper
// ==============================================================================
class InfoButton : public juce::Button
{
public:
    InfoButton() : juce::Button("Info")
    {
        setTooltip("Click for registration instructions");
    }

    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto area = getLocalBounds().toFloat();
        g.setColour(juce::Colours::black);
        g.fillEllipse(area);
        
        g.setColour(juce::Colours::white);
        g.setFont(juce::Font(area.getHeight() * 0.7f, juce::Font::bold));
        g.drawText("i", area, juce::Justification::centred, false);
    }
};

class RegistrationComponent : public juce::Component
{
public:
    RegistrationComponent()
    {
        // --- 1. Header Title ---
        addAndMakeVisible(titleLabel);
        titleLabel.setFont(juce::Font(22.0f, juce::Font::bold));
        titleLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        titleLabel.setJustificationType(juce::Justification::centred);

        // --- 2. User ID Section ---
        addAndMakeVisible(userIdLabel);
        userIdLabel.setText("USER ID", juce::dontSendNotification);
        userIdLabel.setFont(juce::Font(20.0f, juce::Font::bold));
        userIdLabel.setColour(juce::Label::textColourId, juce::Colours::black);
        userIdLabel.setJustificationType(juce::Justification::centred);

        addAndMakeVisible(userIdValue);
        userIdValue.setText(RegistrationManager::getInstance().getMachineIDString(), juce::dontSendNotification);
        userIdValue.setFont(juce::Font(18.0f, juce::Font::bold));
        userIdValue.setColour(juce::Label::textColourId, juce::Colours::black);
        userIdValue.setJustificationType(juce::Justification::centred);

        // --- 3. Info Button ---
        addAndMakeVisible(infoButton);
        infoButton.onClick = [this] { showInstructions(); };

        // --- 4. Instructions / Status ---
        addAndMakeVisible(instructionLabel);
        instructionLabel.setFont(juce::Font(13.0f, juce::Font::bold));
        instructionLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        instructionLabel.setJustificationType(juce::Justification::centred);

        // --- 5. Serial Input (Yellow Box) ---
        addAndMakeVisible(serialEditor);
        serialEditor.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFFFFFF00)); // Yellow
        serialEditor.setColour(juce::TextEditor::textColourId, juce::Colours::black);
        serialEditor.setColour(juce::TextEditor::outlineColourId, juce::Colours::black);
        serialEditor.setColour(juce::TextEditor::focusedOutlineColourId, juce::Colours::black);
        serialEditor.setFont(juce::Font(20.0f));
        serialEditor.setJustification(juce::Justification::centred);

        // --- 6. Save Button (Dark Grey) ---
        addAndMakeVisible(saveButton);
        saveButton.setButtonText("SAVE LICENSE FILE");
        saveButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF333333)); // Dark Grey gradient base
        saveButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
        saveButton.onClick = [this] { checkSerial(); };

        // --- 7. Bottom Status ---
        addAndMakeVisible(bottomStatusLabel);
        bottomStatusLabel.setFont(juce::Font(15.0f, juce::Font::bold));
        bottomStatusLabel.setJustificationType(juce::Justification::centred);

        // --- 8. Registered Serial Display (Hidden by default) ---
        addAndMakeVisible(registeredSerialValue);
        registeredSerialValue.setFont(juce::Font(18.0f, juce::Font::plain));
        registeredSerialValue.setColour(juce::Label::textColourId, juce::Colours::black);
        registeredSerialValue.setJustificationType(juce::Justification::centred);
        registeredSerialValue.setVisible(false);

        updateState();
        setSize(320, 300);
    }

    void paint(juce::Graphics& g) override
    {
        // Orange Background (matching screenshot)
        g.fillAll(juce::Colour(0xFFE08020));
        
        // Black border
        g.setColour(juce::Colours::black);
        g.drawRect(getLocalBounds(), 2);
    }

    void resized() override
    {
        auto area = getLocalBounds().reduced(15);
        
        // Title
        titleLabel.setBounds(area.removeFromTop(30));
        area.removeFromTop(5);

        // User ID Label
        userIdLabel.setBounds(area.removeFromTop(20));
        
        // User ID Value + Info Button
        auto idRow = area.removeFromTop(25);
        int idWidth = 100; 
        int infoSize = 20;
        // Center the ID, place button to its right
        userIdValue.setBounds(idRow.withWidth(idWidth).withX((getWidth() - idWidth)/2));
        infoButton.setBounds(userIdValue.getRight() + 5, idRow.getY() + 2, infoSize, infoSize);

        area.removeFromTop(15);

        // Instruction Text
        instructionLabel.setBounds(area.removeFromTop(40));
        area.removeFromTop(5);

        if (RegistrationManager::getInstance().isProMode())
        {
            // REGISTERED LAYOUT
            serialEditor.setVisible(false);
            saveButton.setVisible(false);
            
            registeredSerialValue.setVisible(true);
            registeredSerialValue.setBounds(area.removeFromTop(30));
        }
        else
        {
            // UNREGISTERED LAYOUT
            registeredSerialValue.setVisible(false);
            serialEditor.setVisible(true);
            saveButton.setVisible(true);

            serialEditor.setBounds(area.removeFromTop(35).reduced(20, 0));
            area.removeFromTop(15);
            saveButton.setBounds(area.removeFromTop(45).reduced(5, 0));
        }

        // Bottom Status
        // Push to bottom
        bottomStatusLabel.setBounds(0, getHeight() - 30, getWidth(), 25);
    }

private:
    juce::Label titleLabel;
    juce::Label userIdLabel;
    juce::Label userIdValue;
    InfoButton infoButton;
    juce::Label instructionLabel;
    juce::TextEditor serialEditor;
    juce::TextButton saveButton;
    juce::Label bottomStatusLabel;
    juce::Label registeredSerialValue;

    void updateState()
    {
        bool isRegistered = RegistrationManager::getInstance().isProMode();

        if (isRegistered)
        {
            titleLabel.setText("REGISTRATION COMPLETE", juce::dontSendNotification);
            
            instructionLabel.setText("SERIAL NUMBER:", juce::dontSendNotification);
            
            // Try to load the serial from file to display it
            juce::File licenseFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                     .getChildFile("OnStage").getChildFile("user_license.wav");
            // Since we can't easily decode it back to string without the logic here, 
            // we will just show "Active" or if you have the plain text serial stored somewhere.
            // For now, we'll show a placeholder or "LICENSE ACTIVE".
            registeredSerialValue.setText("LICENSE ACTIVE", juce::dontSendNotification);

            bottomStatusLabel.setText("REGISTERED", juce::dontSendNotification);
            bottomStatusLabel.setColour(juce::Label::textColourId, juce::Colours::lightgreen); // Green text
        }
        else
        {
            titleLabel.setText("PLEASE REGISTER", juce::dontSendNotification);
            
            instructionLabel.setText("ENTER YOUR SERIAL HERE, AND\nTHEN SAVE AS LICENSE FILE", juce::dontSendNotification);
            
            bottomStatusLabel.setText("NOT REGISTERED", juce::dontSendNotification);
            bottomStatusLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        }
        
        resized(); // Re-layout based on state
    }

    void checkSerial()
    {
        juce::String input = serialEditor.getText().trim();
        bool success = RegistrationManager::getInstance().tryRegister(input);
        
        if (success)
        {
            updateState();
            juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::InfoIcon, 
                "Success", "Registration Successful!\nThank you for supporting us.");
        }
        else
        {
            juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon, 
                "Registration Failed", "Invalid Serial Number.\nPlease check your ID and Serial.");
        }
    }

    void showInstructions()
    {
        juce::String text = 
            "Upgrading to PRO version:\n\n"
            "1. Copy Your Machine ID\n"
            "2. Complete Your Purchase: Return to purchase page and enter\n"
            "   your Machine ID into the text box above your chosen bundle.\n"
            "3. Click \"BUY NOW\" to complete the payment.\n\n"
            "Receive Your Serial Number:\n"
            "After a successful purchase, your serial number will instantly\n"
            "appear in the box above. It will also be sent to your email.\n\n"
            "Register Your Plugin:\n"
            "Copy the serial number, paste it into the registration window\n"
            "back in your DAW, and click \"Save license file\".\n"
            "4. Done";

        // Show a simple alert window as the tooltip (easiest way to show multiline text modally)
        juce::AlertWindow::showMessageBoxAsync(juce::AlertWindow::InfoIcon, "Registration Instructions", text);
    }
};



--------------------------------------------------------------------------------
File: src/UI/SignalLed.h
Size: 1.19 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class SignalLed : public juce::Component
{
public:
    SignalLed() { setOpaque(false); }

    void setOn(bool shouldBeOn)
    {
        if (isOn != shouldBeOn)
        {
            isOn = shouldBeOn;
            repaint();
        }
    }

    void paint(juce::Graphics& g) override
    {
        // Draw centered
        auto bounds = getLocalBounds().toFloat().reduced(3.0f);
        float size = juce::jmin(bounds.getWidth(), bounds.getHeight());
        auto r = bounds.withSizeKeepingCentre(size, size);
        
        // Base color (Bright Green if ON, Dark Green if OFF)
        g.setColour(isOn ? juce::Colour(0xFF00FF00) : juce::Colour(0xFF002200));
        g.fillEllipse(r);
        
        // Glow effect when ON
        if (isOn)
        {
            g.setGradientFill(juce::ColourGradient(
                juce::Colours::white.withAlpha(0.8f), r.getCentre(),
                juce::Colour(0xFF00FF00).withAlpha(0.0f), r.getTopLeft(),
                true));
            g.fillEllipse(r);
        }
        
        // Border
        g.setColour(juce::Colours::black);
        g.drawEllipse(r, 1.0f);
    }

private:
    bool isOn = false;
};



--------------------------------------------------------------------------------
File: src/UI/StyledSlider.h
Size: 14.31 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  Included `LongPressDetector.h`. 2.  Updated `StyledSlider`, `MidiTooltipToggleButton`, `MidiTooltipTextButton`, and `MidiTooltipLabel` to inherit `LongPressDetector`. 3.  Implemented `onLongPress()` to show the tooltip. 4.  Updated mouse handlers to call `handleMouseDown`, `handleMouseDrag`, etc. <!-- end list -->

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include "LongPressDetector.h"

class GoldenSliderLookAndFeel : public juce::LookAndFeel_V4
{
public:
    GoldenSliderLookAndFeel()
    {
        setColour(juce::Slider::thumbColourId, juce::Colour(0xffd4af37));
        setColour(juce::Slider::trackColourId, juce::Colour(0xff202020)); 
        setColour(juce::Slider::backgroundColourId, juce::Colour(0xff202020));
        setColour(juce::ScrollBar::thumbColourId, juce::Colour(0xffd4af37)); 
        setColour(juce::ScrollBar::trackColourId, juce::Colour(0xff1a1a1a));
        setColour(juce::ScrollBar::backgroundColourId, juce::Colour(0xff1a1a1a));
        setColour(juce::ComboBox::backgroundColourId, juce::Colour(0xFFD4AF37)); 
        setColour(juce::ComboBox::textColourId, juce::Colours::black); 
        setColour(juce::ComboBox::arrowColourId, juce::Colours::black);
        setColour(juce::ComboBox::outlineColourId, juce::Colours::black);
        setColour(juce::PopupMenu::backgroundColourId, juce::Colour(0xFFD4AF37));
        setColour(juce::PopupMenu::textColourId, juce::Colours::black);
        setColour(juce::PopupMenu::highlightedBackgroundColourId, juce::Colours::black);
        setColour(juce::PopupMenu::highlightedTextColourId, juce::Colour(0xFFD4AF37));
        setColour(juce::TabbedButtonBar::frontOutlineColourId, juce::Colours::transparentBlack);
    }

    int getTabButtonOverlap (int) override { return 0; }
    int getTabButtonSpaceAroundImage () override { return 0; }

    void drawTabButton (juce::TabBarButton& button, juce::Graphics& g, bool isMouseOver, bool isMouseDown) override
    {
        auto activeArea = button.getActiveArea();
        const auto isFrontTab = button.isFrontTab();
        
        juce::Colour bgColour = isFrontTab ? juce::Colour(0xFF202020) : juce::Colour(0xFFD4AF37);
        juce::Colour textColour = isFrontTab ? juce::Colour(0xFFD4AF37) : juce::Colours::black;

        g.setColour(bgColour);
        g.fillRect(activeArea);
        
        if (!isFrontTab)
        {
            g.setColour(juce::Colour(0xFF202020)); 
            g.fillRect(activeArea.removeFromRight(1));
        }
        
        g.setColour(textColour);
        g.setFont(juce::Font(16.0f, juce::Font::bold));
        g.drawText(button.getButtonText(), activeArea, juce::Justification::centred, true);
    }

    void drawTabbedButtonBarBackground (juce::TabbedButtonBar& bar, juce::Graphics& g) override {
        g.fillAll(juce::Colour(0xFF202020));
    }
    
    void drawComboBox (juce::Graphics& g, int width, int height, bool, int, int, int, int, juce::ComboBox& box) override {
        auto cornerSize = box.findParentComponentOfClass<juce::GroupComponent>() != nullptr ? 0.0f : 3.0f;
        juce::Rectangle<int> boxBounds (0, 0, width, height);
        g.setColour (findColour(juce::ComboBox::backgroundColourId));
        g.fillRoundedRectangle (boxBounds.toFloat(), cornerSize);
        g.setColour (findColour(juce::ComboBox::outlineColourId));
        g.drawRoundedRectangle (boxBounds.toFloat().reduced (0.5f, 0.5f), cornerSize, 1.0f);
        juce::Path triangle;
        float arrowSize = 10.0f;
        float arrowX = width - 15.0f;
        float arrowY = height * 0.5f;
        triangle.addTriangle(arrowX - arrowSize * 0.5f, arrowY - arrowSize * 0.25f,
                             arrowX + arrowSize * 0.5f, arrowY - arrowSize * 0.25f,
                             arrowX, arrowY + arrowSize * 0.25f);
        g.setColour(findColour(juce::ComboBox::arrowColourId)); 
        g.fillPath(triangle);
    }

    void drawLinearSlider(juce::Graphics& g, int x, int y, int width, int height,
        float sliderPos, float minSliderPos, float maxSliderPos,
        const juce::Slider::SliderStyle style, juce::Slider& slider) override
    {
        bool isVertical = (style == juce::Slider::LinearVertical);
        float trackWidth = isVertical ? (float)width * 0.2f : (float)height * 0.25f;
        trackWidth = juce::jlimit(4.0f, 8.0f, trackWidth);
        juce::Rectangle<float> trackBounds;
        if (isVertical) {
            float centerX = x + width * 0.5f;
            trackBounds = juce::Rectangle<float>(centerX - trackWidth * 0.5f, (float)y + 5, trackWidth, (float)height - 10);
        } else {
            float centerY = y + height * 0.5f;
            trackBounds = juce::Rectangle<float>((float)x + 5, centerY - trackWidth * 0.5f, (float)width - 10, trackWidth);
        }
        g.setColour(juce::Colour(0xFF151515));
        g.fillRoundedRectangle(trackBounds, trackWidth * 0.5f);
        g.setColour(juce::Colour(0xFF333333));
        g.drawRoundedRectangle(trackBounds, trackWidth * 0.5f, 1.0f);
        juce::Rectangle<float> fillBounds = trackBounds;
        if (isVertical) {
            fillBounds.setTop(sliderPos);
            fillBounds.setBottom(trackBounds.getBottom());
        } else {
            fillBounds.setRight(sliderPos);
            fillBounds.setWidth(sliderPos - trackBounds.getX());
        }
        if (!fillBounds.isEmpty()) {
            g.setColour(juce::Colour(0xFFD4AF37));
            g.fillRoundedRectangle(fillBounds, trackWidth * 0.5f);
        }
        float thumbSize = isVertical ? (float)width * 0.7f : (float)height * 0.7f;
        thumbSize = juce::jlimit(14.0f, 20.0f, thumbSize);
        float thumbX = isVertical ? x + width * 0.5f - thumbSize * 0.5f : sliderPos - thumbSize * 0.5f;
        float thumbY = isVertical ? sliderPos - thumbSize * 0.5f : y + height * 0.5f - thumbSize * 0.5f;
        juce::Rectangle<float> thumbBounds(thumbX, thumbY, thumbSize, thumbSize);
        g.setColour(juce::Colour(0xFFD4AF37));
        g.fillEllipse(thumbBounds);
        g.setColour(juce::Colours::black);
        g.fillEllipse(thumbBounds.reduced(3.0f)); 
    }

    void drawScrollbar (juce::Graphics& g, juce::ScrollBar& scrollbar, int x, int y, int width, int height,
                        bool isScrollbarVertical, int thumbStartPosition, int thumbSize,
                        bool, bool) override
    {
        g.fillAll (findColour (juce::ScrollBar::backgroundColourId));
        juce::Rectangle<int> thumbBounds;
        if (isScrollbarVertical) thumbBounds = { x + 2, thumbStartPosition, width - 4, thumbSize };
        else thumbBounds = { thumbStartPosition, y + 2, thumbSize, height - 4 };
        g.setColour(findColour(juce::ScrollBar::thumbColourId)); 
        g.fillRoundedRectangle(thumbBounds.toFloat(), 4.0f);
    }
};

// --- TOOLTIP HELPERS ---
class TooltipAutoHideTimer : public juce::Timer {
public: TooltipAutoHideTimer(juce::Component* t) : tooltip(t) {}
    void timerCallback() override { stopTimer(); if (tooltip) tooltip->setVisible(false); }
private: juce::Component* tooltip;
};
class MidiTooltipHelper : public juce::BubbleMessageComponent {
public: MidiTooltipHelper() : hideTimer(this) { setAlwaysOnTop(true); addToDesktop(0); }
    void show(juce::Component* owner, const juce::String& text) {
        juce::AttributedString attString;
        attString.append(text, juce::Font(15.0f, juce::Font::bold), juce::Colours::white);
        showAt(owner->getScreenBounds(), attString, 2000, true, false);
        hideTimer.startTimer(2500);
    }
private: TooltipAutoHideTimer hideTimer;
};
inline void showMidiTooltip(juce::Component* c, const juce::String& m) {
    if (m.isEmpty()) return; static std::unique_ptr<MidiTooltipHelper> t;
    if (!t) t = std::make_unique<MidiTooltipHelper>(); t->show(c, m);
}

// --- WIDGET WRAPPERS ---

class StyledSlider : public juce::Slider, public LongPressDetector {
public:
    StyledSlider(juce::Slider::SliderStyle style = juce::Slider::RotaryVerticalDrag, juce::Slider::TextEntryBoxPosition textBox = juce::Slider::TextBoxBelow)
        : juce::Slider(style, textBox) { setLookAndFeel(&goldenLookAndFeel); setTextBoxStyle(textBox, false, 60, 18); }
    ~StyledSlider() override { setLookAndFeel(nullptr); }
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    
    // Long Press: Show Tooltip
    void onLongPress() override {
        if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo);
    }

    void mouseDown(const juce::MouseEvent& e) override {
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; }
        handleMouseDown(e); // Touch Support
        juce::Slider::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e); // Stop timer
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; // Block if long press occurred
        juce::Slider::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { 
        handleMouseDrag(e); // Stop timer if moved
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::Slider::mouseDrag(e); 
    }
private:
    GoldenSliderLookAndFeel goldenLookAndFeel;
    juce::String midiInfo;
};

class VerticalSlider : public juce::Component {
public:
    VerticalSlider() {
        slider.setSliderStyle(juce::Slider::LinearVertical);
        slider.setTextBoxStyle(juce::Slider::TextBoxBelow, false, 70, 20);
        addAndMakeVisible(slider);
        label.setJustificationType(juce::Justification::centred);
        label.setColour(juce::Label::textColourId, juce::Colours::white);
        addAndMakeVisible(label);
    }
    StyledSlider& getSlider() { return slider; }
    void setLabelText(const juce::String& text) { label.setText(text, juce::dontSendNotification); }
    void setRange(double min, double max, double interval = 0) { slider.setRange(min, max, interval); }
    void setValue(double value, juce::NotificationType notification = juce::dontSendNotification) { slider.setValue(value, notification); }
    double getValue() const { return slider.getValue(); }
    void setTextValueSuffix(const juce::String& suffix) { slider.setTextValueSuffix(suffix); }
    void setNumDecimalPlacesToDisplay(int places) { slider.setNumDecimalPlacesToDisplay(places); }
    void setSkewFactor(double factor) { slider.setSkewFactorFromMidPoint(factor); }
    void setMidiInfo(const juce::String& info) { midiInfo = info; slider.setMidiInfo(info); label.setMidiInfo(info); }
    void resized() override { auto area = getLocalBounds(); label.setBounds(area.removeFromTop(20)); slider.setBounds(area); }
private:
    StyledSlider slider;
    // Label also needs long press support for tooltip
    class InternalLabel : public juce::Label, public LongPressDetector {
    public: 
        void setMidiInfo(const juce::String& info) { midiInfo = info; }
        void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
        void mouseDown(const juce::MouseEvent& e) override { 
            if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
            handleMouseDown(e);
            juce::Label::mouseDown(e); 
        }
        void mouseUp(const juce::MouseEvent& e) override { 
            handleMouseUp(e); 
            if (e.mods.isRightButtonDown() || isLongPressTriggered) return;
            juce::Label::mouseUp(e); 
        }
        void mouseDrag(const juce::MouseEvent& e) override {
            handleMouseDrag(e);
            if (!isLongPressTriggered) juce::Label::mouseDrag(e);
        }
        juce::String midiInfo;
    };
    InternalLabel label;
    juce::String midiInfo;
};

class MidiTooltipToggleButton : public juce::ToggleButton, public LongPressDetector {
public: MidiTooltipToggleButton(const juce::String& text = "") : juce::ToggleButton(text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::ToggleButton::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e);
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::ToggleButton::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::ToggleButton::mouseDrag(e); }
private: juce::String midiInfo;
};

class MidiTooltipTextButton : public juce::TextButton, public LongPressDetector {
public: MidiTooltipTextButton(const juce::String& text = "") : juce::TextButton(text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::TextButton::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e);
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::TextButton::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::TextButton::mouseDrag(e); }
private: juce::String midiInfo;
};

class MidiTooltipLabel : public juce::Label, public LongPressDetector {
public: MidiTooltipLabel(const juce::String& name = "", const juce::String& text = "") : juce::Label(name, text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::Label::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { handleMouseUp(e); if (e.mods.isRightButtonDown() || isLongPressTriggered) return; juce::Label::mouseUp(e); }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::Label::mouseDrag(e); }
private: juce::String midiInfo;
};



--------------------------------------------------------------------------------
File: src/UI/TrackBannerComponent.cpp
Size: 8.30 KB
--------------------------------------------------------------------------------

#include "TrackBannerComponent.h"

TrackBannerComponent::TrackBannerComponent(int index, PlaylistItem& item, 
                                           std::function<void()> onRemove,
                                           std::function<void()> onExpandToggle,
                                           std::function<void()> onSelect,
                                           std::function<void(float)> onVolChange,
                                           std::function<void(int)> onPitchChange,
                                           std::function<void(float)> onSpeedChange)
    : trackIndex(index), itemData(item), 
      onRemoveCallback(onRemove), 
      onExpandToggleCallback(onExpandToggle), onSelectCallback(onSelect),
      onVolChangeCallback(onVolChange), 
      onPitchChangeCallback(onPitchChange),
      onSpeedChangeCallback(onSpeedChange)
{
    itemData.isCrossfade = false;
    addAndMakeVisible(indexLabel);
    indexLabel.setText(juce::String(index + 1), juce::dontSendNotification);
    indexLabel.setJustificationType(juce::Justification::centred);
    indexLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    indexLabel.setInterceptsMouseClicks(false, false); 
    
    addAndMakeVisible(playSelectionButton);
    // FIX: Updated Tooltip to reflect "Load Only" behavior
    playSelectionButton.setTooltip("Select / Load this track");
    playSelectionButton.onClick = onSelectCallback; 

    addAndMakeVisible(removeButton);
    removeButton.setButtonText("X");
    removeButton.setMidiInfo("Remove Track from Playlist");
    removeButton.setColour(juce::TextButton::buttonColourId, juce::Colours::transparentBlack);
    removeButton.setColour(juce::TextButton::textColourOffId, juce::Colours::red);
    removeButton.onClick = onRemoveCallback;

    addChildComponent(crossfadeButton);
    crossfadeButton.setVisible(false);
    crossfadeButton.setButtonText("F");
    crossfadeButton.setToggleState(false, juce::dontSendNotification);
    
    addAndMakeVisible(expandButton);
    // FIX: Using arrow symbols instead of +/-
    expandButton.setButtonText(itemData.isExpanded ? "^" : "v");
    expandButton.setMidiInfo("Show/Hide Controls (Volume, Pitch, Speed, Wait)");
    expandButton.setColour(juce::TextButton::buttonColourId, juce::Colours::transparentBlack);
    expandButton.onClick = onExpandToggleCallback;

    if (itemData.isExpanded)
    {
        // --- 1. VOLUME ---
        volSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        volSlider->setMidiInfo("Track Gain (0dB to +22dB)"); 
        volSlider->setRange(0.0, 2.0, 0.01);
        float initSliderVal = 0.0f;
        if (itemData.volume > 0.0001f) {
            float db = juce::Decibels::gainToDecibels(itemData.volume);
            float norm = (db / 44.0f) + 0.5f;
            initSliderVal = juce::jlimit(0.0f, 2.0f, norm * 2.0f);
        }
        volSlider->setValue(initSliderVal, juce::dontSendNotification);
        volSlider->onValueChange = [this] { 
            float sliderVal = (float)volSlider->getValue();
            float linear = 0.0f;
            if (sliderVal > 0.0f) {
                float norm = sliderVal / 2.0f;
                float db = (norm - 0.5f) * 44.0f;
                linear = juce::Decibels::decibelsToGain(db);
            }
            itemData.volume = linear;
            if (onVolChangeCallback) onVolChangeCallback(itemData.volume);
        };
        addAndMakeVisible(volSlider.get());

        // --- 2. PITCH ---
        pitchSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        pitchSlider->setMidiInfo("Pitch Shift (-12 to +12 semitones)");
        pitchSlider->setRange(-12.0, 12.0, 1.0); 
        pitchSlider->setValue(itemData.pitchSemitones, juce::dontSendNotification);
        pitchSlider->setTextValueSuffix(" st");
        pitchSlider->onValueChange = [this] {
            itemData.pitchSemitones = (int)pitchSlider->getValue();
            if (onPitchChangeCallback) onPitchChangeCallback(itemData.pitchSemitones);
        };
        addAndMakeVisible(pitchSlider.get());

        // --- 3. SPEED ---
        speedSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        speedSlider->setMidiInfo("Playback Speed (0.1x - 2.1x)");
        speedSlider->setRange(0.1, 2.1, 0.01);
        speedSlider->setValue(itemData.playbackSpeed, juce::dontSendNotification);
        speedSlider->onValueChange = [this] { 
            itemData.playbackSpeed = (float)speedSlider->getValue();
            if (onSpeedChangeCallback) onSpeedChangeCallback(itemData.playbackSpeed);
        };
        addAndMakeVisible(speedSlider.get());

        // --- 4. WAIT ---
        delaySlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        delaySlider->setMidiInfo("Transition Wait Time");
        delaySlider->setRange(0.0, 30.0, 1.0);
        delaySlider->setValue(itemData.transitionDelaySec, juce::dontSendNotification);
        delaySlider->setTextValueSuffix(" s (Wait)");
        delaySlider->textFromValueFunction = [this](double value) {
            return juce::String(value, 0) + " s";
        };
        delaySlider->onValueChange = [this] { 
            itemData.transitionDelaySec = (int)delaySlider->getValue();
        };
        addAndMakeVisible(delaySlider.get());

        addAndMakeVisible(volLabel); volLabel.setText("Vol", juce::dontSendNotification);
        addAndMakeVisible(pitchLabel); pitchLabel.setText("Pitch", juce::dontSendNotification);
        addAndMakeVisible(speedLabel); speedLabel.setText("Speed", juce::dontSendNotification);
        addAndMakeVisible(delayLabel); delayLabel.setText("Wait", juce::dontSendNotification);
    }
}

void TrackBannerComponent::onLongPress()
{
    showMidiTooltip(this, "Track: " + itemData.title + "\nLeft-Click Triangle to Load Only");
}

void TrackBannerComponent::mouseDown(const juce::MouseEvent& e)
{
    if (e.mods.isRightButtonDown()) { onLongPress(); return; }
    handleMouseDown(e);
}

void TrackBannerComponent::mouseUp(const juce::MouseEvent& e)
{
    handleMouseUp(e);
}

void TrackBannerComponent::mouseDrag(const juce::MouseEvent& e)
{
    handleMouseDrag(e);
}

void TrackBannerComponent::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    if (isCurrentTrack) g.setColour(juce::Colour(0xFF152215)); 
    else g.setColour(juce::Colour(0xFF1A1A1A));

    g.fillRoundedRectangle(bounds, 10.0f);
    
    if (isCurrentTrack) {
        g.setColour(juce::Colour(0xFF008800));
        g.drawRoundedRectangle(bounds, 10.0f, 2.0f);
    } else {
        g.setColour(juce::Colour(0xFF404040)); 
        g.drawRoundedRectangle(bounds, 10.0f, 1.0f);
    }

    g.setColour(juce::Colour(0xFFD4AF37));
    g.setFont(juce::Font(15.0f, juce::Font::bold));
    auto textArea = getLocalBounds().reduced(5).withTrimmedLeft(70).withTrimmedRight(110).withHeight(34);
    g.drawFittedText(itemData.title, textArea, juce::Justification::centredLeft, 1);
}

void TrackBannerComponent::resized()
{
    auto bounds = getLocalBounds();
    indexLabel.setBounds(5, 10, 24, 24);
    playSelectionButton.setBounds(35, 7, 30, 30);
    
    expandButton.setBounds(bounds.getWidth() - 30, 10, 20, 20);
    removeButton.setBounds(bounds.getWidth() - 60, 10, 20, 20);

    if (itemData.isExpanded)
    {
        int startY = 44;
        int rowH = 30;
        int labelW = 40;
        int sliderX = 10 + labelW;
        int sliderW = bounds.getWidth() - 20 - labelW;
        
        // Row 1: Vol
        volLabel.setBounds(10, startY, labelW, rowH);
        volSlider->setBounds(sliderX, startY, sliderW, rowH);
        
        // Row 2: Pitch
        pitchLabel.setBounds(10, startY + rowH, labelW, rowH);
        pitchSlider->setBounds(sliderX, startY + rowH, sliderW, rowH);
        
        // Row 3: Speed
        speedLabel.setBounds(10, startY + rowH*2, labelW, rowH);
        speedSlider->setBounds(sliderX, startY + rowH*2, sliderW, rowH);
        
        // Row 4: Wait
        delayLabel.setBounds(10, startY + rowH*3, labelW, rowH);
        delaySlider->setBounds(sliderX, startY + rowH*3, sliderW, rowH);
    }
}

void TrackBannerComponent::setPlaybackState(bool isCurrent, bool isAudioActive)
{
    isCurrentTrack = isCurrent;
    isAudioPlaying = isAudioActive;
    playSelectionButton.setActive(isCurrent);
    repaint();
}



--------------------------------------------------------------------------------
File: src/UI/TrackBannerComponent.h
Size: 3.24 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "PlaylistDataStructures.h"
#include "StyledSlider.h"
#include "LongPressDetector.h"

class PlayTriangleButton : public juce::Button
{
public:
    PlayTriangleButton() : juce::Button("PlaySelect") {}
    
    void setActive(bool active)
    {
        if (isActive != active)
        {
            isActive = active;
            repaint();
        }
    }
    
    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto bounds = getLocalBounds().toFloat();
        if (isActive) g.setColour(juce::Colour(0xFF335533));
        else g.setColour(juce::Colour(0xFF2A2A2A));
        
        if (shouldDrawButtonAsHighlighted) g.setColour(juce::Colour(0xFF3A3A3A));
        
        g.fillEllipse(bounds.reduced(2));
        
        juce::Path p;
        float s = bounds.getHeight() * 0.4f;
        float cx = bounds.getCentreX() + 2; 
        float cy = bounds.getCentreY();
        p.addTriangle(cx - s/2, cy - s/2, cx - s/2, cy + s/2, cx + s/2, cy);
        g.setColour(isActive ? juce::Colour(0xFF00FF00) : juce::Colour(0xFF008800));
        g.fillPath(p);

        if (isActive)
        {
            g.setColour(juce::Colour(0xFF00FF00));
            g.drawEllipse(bounds.reduced(2), 1.5f);
        }
    }

private:
    bool isActive = false;
};

class TrackBannerComponent : public juce::Component, public LongPressDetector
{
public:
    TrackBannerComponent(int index, PlaylistItem& item, 
                         std::function<void()> onRemove,
                         std::function<void()> onExpandToggle,
                         std::function<void()> onSelect,
                         std::function<void(float)> onVolChange,
                         std::function<void(int)> onPitchChange,
                         std::function<void(float)> onSpeedChange);

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void onLongPress() override;

    void setPlaybackState(bool isCurrent, bool isAudioActive);
    bool isExpanded() const { return itemData.isExpanded; }

private:
    int trackIndex;
    PlaylistItem& itemData;
    
    bool isCurrentTrack = false;
    bool isAudioPlaying = false;

    std::function<void()> onRemoveCallback;
    std::function<void()> onExpandToggleCallback;
    std::function<void()> onSelectCallback;
    std::function<void(float)> onVolChangeCallback;
    std::function<void(int)> onPitchChangeCallback; 
    std::function<void(float)> onSpeedChangeCallback;

    juce::Label indexLabel;
    PlayTriangleButton playSelectionButton;
    
    MidiTooltipTextButton removeButton;
    MidiTooltipTextButton expandButton;
    MidiTooltipTextButton crossfadeButton;

    juce::Label volLabel, pitchLabel, speedLabel, delayLabel;
    
    std::unique_ptr<StyledSlider> volSlider;
    std::unique_ptr<StyledSlider> pitchSlider;
    std::unique_ptr<StyledSlider> speedSlider;
    std::unique_ptr<StyledSlider> delaySlider;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TrackBannerComponent)
};



--------------------------------------------------------------------------------
File: CMakeLists.txt
Size: 10.69 KB
--------------------------------------------------------------------------------

cmake_minimum_required(VERSION 3.22)

# --- PROJECT SETUP ---
project(Playlisted LANGUAGES C CXX VERSION 2.0.0)

# --- CCACHE ---
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
    message(STATUS "Using CCache: ${CCACHE_PROGRAM}")
    set(CMAKE_CXX_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
endif()

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set_property(GLOBAL PROPERTY USE_FOLDERS YES)

# --- PATHS ---
set(PROJECT_ROOT "${CMAKE_CURRENT_SOURCE_DIR}")
set(ASSETS_DIR   "${PROJECT_ROOT}/assets")
set(SRC_DIR      "${PROJECT_ROOT}/src")

# --- PLATFORM DETECTION ---
if(CMAKE_SYSTEM_NAME STREQUAL "iOS")
    set(IOS TRUE)
    message(STATUS "Building for iOS")
endif()

# --- JUCE SETUP (MUST BE FIRST) ---
if(NOT DEFINED JUCE_DIR)
    set(JUCE_DIR "D:/Workspace/JUCE") 
endif()

if(EXISTS "${JUCE_DIR}/CMakeLists.txt")
    add_subdirectory("${JUCE_DIR}" "${CMAKE_BINARY_DIR}/JUCE_Build")
else()
    message(FATAL_ERROR "JUCE directory not found at ${JUCE_DIR}!")
endif()

# --- CLAP EXTENSIONS SETUP (Desktop only) ---
if(NOT IOS)
    if(NOT DEFINED CLAP_EXTENSIONS_DIR)
        set(CLAP_EXTENSIONS_DIR "${PROJECT_ROOT}/libs/CLAP_Extensions") 
    endif()

    get_filename_component(CLAP_EXTENSIONS_ABS "${CLAP_EXTENSIONS_DIR}" ABSOLUTE)
    message(STATUS "CLAP Extension Path: ${CLAP_EXTENSIONS_ABS}")

    add_subdirectory("${CLAP_EXTENSIONS_ABS}" "${CMAKE_BINARY_DIR}/CLAP_Extensions_Build")
endif()

# ==============================================================================
# 1. PLAYLISTED ENGINE (Desktop only)
# ==============================================================================
if(NOT IOS)
    set(SHARED_SOURCES ${SRC_DIR}/AppLogger.h ${SRC_DIR}/IPC/SharedMemoryManager.h)
    set(ENGINE_SOURCES ${SHARED_SOURCES} ${SRC_DIR}/EngineMain.cpp)

    if(WIN32)
        list(APPEND ENGINE_SOURCES ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.cpp ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.h)
    elseif(APPLE)
        list(APPEND ENGINE_SOURCES ${SRC_DIR}/engine/NativeMediaPlayer_Apple.mm ${SRC_DIR}/engine/NativeMediaPlayer_Apple.h)
    endif()

    juce_add_gui_app(PlaylistedEngine PRODUCT_NAME "PlaylistedEngine" VERSION "2.0.0" ICON_BIG "${ASSETS_DIR}/logo.png")
    target_sources(PlaylistedEngine PRIVATE ${ENGINE_SOURCES})

    if(WIN32)
        add_definitions(-DJUCE_WINDOWS=1)
        set(VLC_DIR "${PROJECT_ROOT}/vlc-3.0.21")
        target_include_directories(PlaylistedEngine PRIVATE ${VLC_DIR}/sdk/include)
        target_link_libraries(PlaylistedEngine PRIVATE "${VLC_DIR}/sdk/lib/libvlc.lib" "${VLC_DIR}/sdk/lib/libvlccore.lib" winmm ws2_32 gdi32 ole32 uuid comdlg32 shlwapi)
        add_custom_command(TARGET PlaylistedEngine POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlc.dll" "$<TARGET_FILE_DIR:PlaylistedEngine>")
        add_custom_command(TARGET PlaylistedEngine POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlccore.dll" "$<TARGET_FILE_DIR:PlaylistedEngine>")
        add_custom_command(TARGET PlaylistedEngine POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory "${VLC_DIR}/plugins" "$<TARGET_FILE_DIR:PlaylistedEngine>/plugins")
    elseif(APPLE)
        add_definitions(-DJUCE_MAC=1)
        target_link_libraries(PlaylistedEngine PRIVATE "-framework Cocoa" "-framework CoreAudio" "-framework CoreMIDI" "-framework AudioToolbox" "-framework IOKit" "-framework Accelerate" "-framework QuartzCore" "-framework WebKit" "-framework Foundation" "-framework AVFoundation" "-framework CoreMedia" "-framework CoreVideo")
    endif()

    target_link_libraries(PlaylistedEngine PRIVATE juce::juce_core juce::juce_events juce::juce_graphics juce::juce_gui_basics juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats)
endif()

# ==============================================================================
# 2. PLAYLISTED PLUGIN
# ==============================================================================
set(PLUGIN_SOURCES ${SRC_DIR}/AudioEngine.cpp ${SRC_DIR}/AudioEngine.h ${SRC_DIR}/IOSettingsManager.cpp ${SRC_DIR}/IOSettingsManager.h ${SRC_DIR}/RegistrationManager.cpp ${SRC_DIR}/RegistrationManager.h ${SRC_DIR}/PluginProcessor.cpp ${SRC_DIR}/PluginProcessor.h ${SRC_DIR}/PluginEditor.cpp ${SRC_DIR}/PluginEditor.h ${SRC_DIR}/engine/VideoSurfaceComponent.cpp ${SRC_DIR}/engine/VideoSurfaceComponent.h ${SRC_DIR}/UI/MainComponent.cpp ${SRC_DIR}/UI/MainComponent.h ${SRC_DIR}/UI/HeaderBar.cpp ${SRC_DIR}/UI/HeaderBar.h ${SRC_DIR}/UI/RegistrationComponent.h ${SRC_DIR}/UI/MediaPage.cpp ${SRC_DIR}/UI/MediaPage.h ${SRC_DIR}/UI/PlaylistComponent.cpp ${SRC_DIR}/UI/PlaylistComponent.h ${SRC_DIR}/UI/TrackBannerComponent.cpp ${SRC_DIR}/UI/TrackBannerComponent.h ${SRC_DIR}/UI/PlaylistDataStructures.h ${SRC_DIR}/UI/DebugConsole.h ${SRC_DIR}/UI/ManualComponent.h ${SRC_DIR}/UI/LongPressDetector.h ${SRC_DIR}/UI/StyledSlider.h ${SRC_DIR}/UI/SignalLed.h)

# Add desktop-specific sources
if(NOT IOS)
    list(APPEND PLUGIN_SOURCES ${SRC_DIR}/AppLogger.h ${SRC_DIR}/IPC/SharedMemoryManager.h "${PROJECT_ROOT}/resources.rc")
else()
    # iOS-specific sources (AVFoundation player instead of Engine)
    list(APPEND PLUGIN_SOURCES ${SRC_DIR}/engine/NativeMediaPlayer_Apple.mm ${SRC_DIR}/engine/NativeMediaPlayer_Apple.h)
endif()

# Determine plugin formats
if(IOS)
    set(PLUGIN_FORMATS AUv3 Standalone)
else()
    set(PLUGIN_FORMATS VST3 AU CLAP)
endif()

# Binary Data (Linked globally to avoid missing header issues)
juce_add_binary_data(OnStageAssets SOURCES "${ASSETS_DIR}/logo.png" "${ASSETS_DIR}/playlisted2.png" "${ASSETS_DIR}/ir.wav" "${ASSETS_DIR}/license.mid")

juce_add_plugin(Playlisted 
    COMPANY_NAME "Fanan" 
    IS_SYNTH TRUE 
    NEEDS_MIDI_INPUT TRUE 
    NEEDS_MIDI_OUTPUT FALSE 
    IS_MIDI_EFFECT FALSE 
    EDITOR_WANTS_KEYBOARD_FOCUS TRUE 
    COPY_PLUGIN_AFTER_BUILD TRUE 
    FORMATS ${PLUGIN_FORMATS}
    PRODUCT_NAME "Playlisted2" 
    VERSION "2.0.0"
    BUNDLE_ID "com.fanan.playlisted2"
    IPHONE_SCREEN_ORIENTATIONS UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    IPAD_SCREEN_ORIENTATIONS UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight)

target_sources(Playlisted PRIVATE ${PLUGIN_SOURCES})
target_compile_definitions(Playlisted PRIVATE JUCE_VST3_CAN_REPLACE_VST2=0)

# Link Assets Globally
target_link_libraries(Playlisted PRIVATE OnStageAssets)

# iOS-specific settings
if(IOS)
    foreach(TARGET_NAME Playlisted_AUv3 Playlisted_Standalone)
        set_target_properties(${TARGET_NAME} PROPERTIES
            XCODE_ATTRIBUTE_IPHONEOS_DEPLOYMENT_TARGET "12.0"
            XCODE_ATTRIBUTE_TARGETED_DEVICE_FAMILY "1,2"
            XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY "iPhone Distribution"
            XCODE_ATTRIBUTE_DEVELOPMENT_TEAM "${IOS_TEAM_ID}"
        )
        
        target_link_libraries(${TARGET_NAME} PRIVATE 
            "-framework UIKit"
            "-framework AVFoundation"
            "-framework CoreAudio"
            "-framework CoreMIDI"
            "-framework AudioToolbox"
            "-framework Accelerate"
            "-framework QuartzCore"
            "-framework CoreMedia"
            "-framework CoreVideo"
        )
    endforeach()

    # AUv3: Force MANUAL signing
    if(IOS_AUV3_PROFILE_ID)
        set_target_properties(Playlisted_AUv3 PROPERTIES
            XCODE_ATTRIBUTE_PROVISIONING_PROFILE_SPECIFIER "${IOS_AUV3_PROFILE_ID}"
            XCODE_ATTRIBUTE_CODE_SIGN_STYLE "Manual"
        )
    endif()

    # Standalone App: Manual if profile exists, else Automatic
    if(IOS_APP_PROFILE_ID)
        set_target_properties(Playlisted_Standalone PROPERTIES
            XCODE_ATTRIBUTE_PROVISIONING_PROFILE_SPECIFIER "${IOS_APP_PROFILE_ID}"
            XCODE_ATTRIBUTE_CODE_SIGN_STYLE "Manual"
        )
    else()
        message(STATUS "No App Profile ID provided. Defaulting Standalone to Automatic Signing.")
        set_target_properties(Playlisted_Standalone PROPERTIES
            XCODE_ATTRIBUTE_CODE_SIGN_STYLE "Automatic"
        )
    endif()
    
    # Copy assets
    add_custom_command(TARGET Playlisted_Standalone POST_BUILD 
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${ASSETS_DIR}" "$<TARGET_FILE_DIR:Playlisted_Standalone>/assets")
        
    add_custom_command(TARGET Playlisted_AUv3 POST_BUILD 
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${ASSETS_DIR}" "$<TARGET_FILE_DIR:Playlisted_AUv3>/../Resources/assets")
else()
    # Enable CLAP for desktop
    target_link_libraries(Playlisted PRIVATE clap_juce_extensions)
    clap_juce_extensions_plugin(TARGET Playlisted
                                 CLAP_ID "com.fanan.playlisted2"
                                 CLAP_FEATURES instrument)
    
    add_dependencies(Playlisted PlaylistedEngine)
endif()

if(WIN32)
    target_link_libraries(Playlisted PRIVATE winmm ws2_32 gdi32 ole32 uuid comdlg32 shlwapi)
    macro(copy_engine_to_target target_name)
        if(TARGET ${target_name})
            add_custom_command(TARGET ${target_name} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "$<TARGET_FILE:PlaylistedEngine>" "$<TARGET_FILE_DIR:${target_name}>/PlaylistedEngine.exe")
            add_custom_command(TARGET ${target_name} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlc.dll" "$<TARGET_FILE_DIR:${target_name}>/")
            add_custom_command(TARGET ${target_name} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlccore.dll" "$<TARGET_FILE_DIR:${target_name}>/")
            add_custom_command(TARGET ${target_name} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory "${VLC_DIR}/plugins" "$<TARGET_FILE_DIR:${target_name}>/plugins")
        endif()
    endmacro()
    copy_engine_to_target(Playlisted_VST3)
    copy_engine_to_target(Playlisted_CLAP)
elseif(APPLE AND NOT IOS)
    target_link_libraries(Playlisted PRIVATE "-framework Cocoa" "-framework Foundation")
    add_custom_command(TARGET Playlisted POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory "${ASSETS_DIR}" "$<TARGET_FILE_DIR:Playlisted>/../Resources/assets")
    
    macro(copy_mac_engine target_name)
        if(TARGET ${target_name})
            add_custom_command(TARGET ${target_name} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "$<TARGET_FILE:PlaylistedEngine>" "$<TARGET_FILE_DIR:${target_name}>/../Resources/PlaylistedEngine")
        endif()
    endmacro()
    
    copy_mac_engine(Playlisted_VST3)
    copy_mac_engine(Playlisted_CLAP)
    copy_mac_engine(Playlisted_AU)
endif()

target_include_directories(Playlisted PRIVATE ${PROJECT_ROOT} ${SRC_DIR} ${SRC_DIR}/engine ${SRC_DIR}/UI)
target_link_libraries(Playlisted PRIVATE juce::juce_core juce::juce_events juce::juce_data_structures juce::juce_graphics juce::juce_gui_basics juce::juce_gui_extra juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats juce::juce_audio_utils juce::juce_audio_processors juce::juce_dsp juce::juce_audio_plugin_client)


================================================================================
End of Documentation
Generated by Code PDF Builder on January 31, 2026
================================================================================
